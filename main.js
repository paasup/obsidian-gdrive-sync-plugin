/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GDriveSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  clientId: "",
  clientSecret: "",
  apiKey: "",
  syncFolders: [],
  syncWholeVault: false,
  autoSync: false,
  syncInterval: 3e5,
  accessToken: "",
  driveFolder: "Obsidian-Sync",
  includeSubfolders: true,
  syncMode: "modified",
  lastSyncTime: 0,
  syncDirection: "bidirectional",
  // 기본값: 양방향
  conflictResolution: "newer",
  // 기본값: 더 최신 파일 우선
  createMissingFolders: true
  // 기본값: 누락된 폴더 자동 생성
};
var FolderTreeModal = class extends import_obsidian.Modal {
  constructor(app, plugin, onChoose) {
    super(app);
    this.expandedFolders = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.onChoose = onChoose;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Folder to Sync" });
    const treeContainer = contentEl.createEl("div", {
      cls: "folder-tree-container",
      attr: {
        style: "max-height: 400px; overflow-y: auto; border: 1px solid var(--background-modifier-border); border-radius: 4px; padding: 10px; margin: 10px 0;"
      }
    });
    this.renderFolderTree(treeContainer);
    const buttonContainer = contentEl.createEl("div", {
      attr: { style: "text-align: right; margin-top: 15px;" }
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      attr: { style: "margin-right: 10px;" }
    });
    cancelButton.onclick = () => this.close();
    const selectRootButton = buttonContainer.createEl("button", {
      text: "Select Vault Root",
      cls: "mod-cta",
      attr: { style: "margin-right: 10px;" }
    });
    selectRootButton.onclick = () => {
      this.onChoose(this.app.vault.getRoot());
      this.close();
    };
  }
  renderFolderTree(container) {
    const rootFolder = this.app.vault.getRoot();
    const rootFolders = rootFolder.children.filter((child) => child instanceof import_obsidian.TFolder).sort((a, b) => a.name.localeCompare(b.name));
    rootFolders.forEach((folder) => {
      this.renderFolderNode(container, folder, 0);
    });
  }
  renderFolderNode(container, folder, depth) {
    const nodeEl = container.createEl("div", {
      cls: "folder-tree-node",
      attr: {
        style: `margin-left: ${depth * 20}px; cursor: pointer; padding: 4px 8px; border-radius: 4px; margin-bottom: 2px;`
      }
    });
    nodeEl.addEventListener("mouseenter", () => {
      nodeEl.style.backgroundColor = "var(--background-modifier-hover)";
    });
    nodeEl.addEventListener("mouseleave", () => {
      nodeEl.style.backgroundColor = "transparent";
    });
    const hasChildren = folder.children.some((child) => child instanceof import_obsidian.TFolder);
    const isExpanded = this.expandedFolders.has(folder.path);
    const folderContent = nodeEl.createEl("div", {
      attr: { style: "display: flex; align-items: center;" }
    });
    const expandIcon = folderContent.createEl("span", {
      text: hasChildren ? isExpanded ? "\u25BC" : "\u25B6" : "  ",
      attr: {
        style: "margin-right: 8px; width: 12px; display: inline-block; font-size: 10px;"
      }
    });
    const folderIcon = folderContent.createEl("span", {
      text: "\u{1F4C1}",
      attr: { style: "margin-right: 6px;" }
    });
    const folderName = folderContent.createEl("span", {
      text: folder.name || "Vault Root",
      attr: { style: "flex-grow: 1;" }
    });
    const selectBtn = folderContent.createEl("button", {
      text: "Select",
      cls: "mod-small",
      attr: {
        style: "margin-left: 10px; padding: 2px 8px; font-size: 11px;"
      }
    });
    expandIcon.onclick = (e) => {
      e.stopPropagation();
      if (hasChildren) {
        this.toggleFolder(folder.path, container);
      }
    };
    folderName.onclick = () => {
      if (hasChildren) {
        this.toggleFolder(folder.path, container);
      }
    };
    selectBtn.onclick = (e) => {
      e.stopPropagation();
      this.onChoose(folder);
      this.close();
    };
    if (hasChildren && isExpanded) {
      const subFolders = folder.children.filter((child) => child instanceof import_obsidian.TFolder).sort((a, b) => a.name.localeCompare(b.name));
      subFolders.forEach((subFolder) => {
        this.renderFolderNode(container, subFolder, depth + 1);
      });
    }
  }
  toggleFolder(folderPath, container) {
    if (this.expandedFolders.has(folderPath)) {
      this.expandedFolders.delete(folderPath);
    } else {
      this.expandedFolders.add(folderPath);
    }
    container.empty();
    this.renderFolderTree(container);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var GDriveSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    this.isGoogleApiLoaded = false;
  }
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon("cloud", "Google Drive Sync", (evt) => {
      this.syncWithGoogleDrive();
    });
    ribbonIconEl.addClass("gdrive-sync-ribbon-class");
    this.addCommand({
      id: "sync-with-gdrive",
      name: "Sync with Google Drive",
      callback: () => {
        this.syncWithGoogleDrive();
      }
    });
    this.addCommand({
      id: "download-from-gdrive",
      name: "Download from Google Drive",
      callback: () => {
        this.downloadFromGoogleDrive();
      }
    });
    this.addCommand({
      id: "upload-to-gdrive",
      name: "Upload to Google Drive",
      callback: () => {
        this.uploadToGoogleDrive();
      }
    });
    this.addSettingTab(new GDriveSyncSettingTab(this.app, this));
    console.log("Plugin loaded - Desktop App authentication mode with bidirectional sync support");
    if (this.settings.autoSync) {
      this.setupAutoSync();
    }
  }
  onunload() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const oldData = await this.loadData();
    if (oldData && oldData.syncFolder && !oldData.syncFolders) {
      this.settings.syncFolders = [oldData.syncFolder];
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // 기존 인증 메서드들은 동일하게 유지
  async authenticateGoogleDrive() {
    console.log("=== Starting Google Drive Desktop Authentication ===");
    if (!this.settings.clientId || !this.settings.clientSecret || !this.settings.apiKey) {
      console.error("Missing credentials");
      new import_obsidian.Notice("\u274C Please set Client ID, Client Secret, and API Key in settings first.");
      return false;
    }
    console.log("\u2713 Credentials are set");
    const authUrl = this.generateAuthUrl();
    new import_obsidian.Notice("Opening browser for Desktop App authentication...");
    console.log("Desktop Auth URL:", authUrl);
    try {
      window.open(authUrl, "_blank");
      new import_obsidian.Notice('\u{1F517} Complete authentication in browser, then copy the authorization code and use "Authorization Code" input in settings.');
      return false;
    } catch (error) {
      console.error("Failed to open browser:", error);
      try {
        navigator.clipboard.writeText(authUrl);
        new import_obsidian.Notice("\u{1F4CB} Auth URL copied to clipboard. Open it in your browser.");
      } catch (clipboardError) {
        console.error("Failed to copy to clipboard:", clipboardError);
        new import_obsidian.Notice("\u274C Failed to open browser. Please check console for auth URL.");
      }
      return false;
    }
  }
  generateAuthUrl() {
    const params = new URLSearchParams({
      client_id: this.settings.clientId,
      redirect_uri: "urn:ietf:wg:oauth:2.0:oob",
      scope: "https://www.googleapis.com/auth/drive.file",
      response_type: "code",
      access_type: "offline",
      prompt: "consent"
    });
    return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
  }
  async exchangeCodeForToken(authCode) {
    try {
      console.log("Exchanging authorization code for access token...");
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://oauth2.googleapis.com/token",
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          client_id: this.settings.clientId,
          client_secret: this.settings.clientSecret,
          code: authCode,
          grant_type: "authorization_code",
          redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
        }).toString(),
        throw: false
      });
      if (response.status === 200) {
        const tokenData = response.json;
        console.log("Token exchange successful");
        this.settings.accessToken = tokenData.access_token;
        await this.saveSettings();
        new import_obsidian.Notice("\u2705 Desktop App authentication successful!");
        return true;
      } else {
        console.error("Token exchange failed:", response.status, response.json);
        new import_obsidian.Notice("\u274C Failed to exchange authorization code for token.");
        return false;
      }
    } catch (error) {
      console.error("Token exchange error:", error);
      new import_obsidian.Notice("\u274C Token exchange failed. Check console for details.");
      return false;
    }
  }
  async revokeGoogleDriveAccess() {
    try {
      console.log("Revoking Google Drive access...");
      if (!this.settings.accessToken) {
        console.log("No access token to revoke");
        new import_obsidian.Notice("No active session to revoke");
        return true;
      }
      this.settings.accessToken = "";
      await this.saveSettings();
      console.log("\u2713 Google Drive access revoked successfully");
      new import_obsidian.Notice("Google Drive access revoked successfully");
      return true;
    } catch (error) {
      console.error("Failed to revoke access:", error);
      new import_obsidian.Notice("Failed to revoke access. Token cleared locally.");
      this.settings.accessToken = "";
      await this.saveSettings();
      return false;
    }
  }
  isAuthenticated() {
    return !!this.settings.accessToken;
  }
  // 메인 동기화 메서드 (양방향)
  async syncWithGoogleDrive() {
    if (!this.settings.clientId || !this.settings.clientSecret || !this.settings.apiKey) {
      new import_obsidian.Notice("Please configure Google Drive API credentials in settings");
      return this.createEmptyResult();
    }
    if (!this.settings.syncWholeVault && this.settings.syncFolders.length === 0) {
      new import_obsidian.Notice('Please select folders to sync or enable "Sync Whole Vault" in settings');
      return this.createEmptyResult();
    }
    new import_obsidian.Notice("Starting Google Drive sync...");
    try {
      if (!this.isAuthenticated()) {
        new import_obsidian.Notice("Please authenticate first using the Desktop App method.");
        return this.createEmptyResult();
      }
      let result;
      if (this.settings.syncDirection === "upload") {
        result = await this.uploadToGoogleDrive();
      } else if (this.settings.syncDirection === "download") {
        result = await this.downloadFromGoogleDrive();
      } else {
        result = await this.bidirectionalSync();
      }
      this.reportSyncResult(result);
      return result;
    } catch (error) {
      console.error("Sync failed:", error);
      new import_obsidian.Notice("Google Drive sync failed");
      return this.createEmptyResult();
    }
  }
  // 업로드 전용 메서드
  async uploadToGoogleDrive() {
    console.log("Starting upload to Google Drive...");
    const result = this.createEmptyResult();
    try {
      const driveFolder = await this.getOrCreateDriveFolder();
      if (!driveFolder) {
        new import_obsidian.Notice("\u274C Failed to create or find Google Drive folder");
        return result;
      }
      if (this.settings.syncWholeVault) {
        const allFiles = this.app.vault.getFiles();
        const filesToSync = allFiles.filter((file) => this.shouldSyncFileType(file));
        await this.uploadFilesToDrive(filesToSync, driveFolder.id, result);
      } else {
        for (const folderPath of this.settings.syncFolders) {
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (folder && folder instanceof import_obsidian.TFolder) {
            const filesToSync = await this.collectFilesToSync(folder, this.settings.includeSubfolders);
            await this.uploadFilesToDrive(filesToSync, driveFolder.id, result);
          }
        }
      }
      this.settings.lastSyncTime = Date.now();
      await this.saveSettings();
    } catch (error) {
      console.error("Upload error:", error);
      result.errors++;
    }
    return result;
  }
  // 다운로드 전용 메서드
  async downloadFromGoogleDrive() {
    console.log("Starting download from Google Drive...");
    const result = this.createEmptyResult();
    try {
      const driveFolder = await this.getOrCreateDriveFolder();
      if (!driveFolder) {
        new import_obsidian.Notice("\u274C Failed to find Google Drive folder");
        return result;
      }
      const driveFiles = await this.getAllFilesFromDrive(driveFolder.id);
      console.log(`Found ${driveFiles.length} files in Google Drive`);
      for (const driveFile of driveFiles) {
        try {
          await this.downloadFileFromDrive(driveFile, result);
        } catch (error) {
          console.error(`Error downloading file ${driveFile.name}:`, error);
          result.errors++;
        }
      }
      this.settings.lastSyncTime = Date.now();
      await this.saveSettings();
    } catch (error) {
      console.error("Download error:", error);
      result.errors++;
    }
    return result;
  }
  // 양방향 동기화 메서드
  async bidirectionalSync() {
    console.log("Starting bidirectional sync...");
    const result = this.createEmptyResult();
    try {
      const driveFolder = await this.getOrCreateDriveFolder();
      if (!driveFolder) {
        new import_obsidian.Notice("\u274C Failed to create or find Google Drive folder");
        return result;
      }
      let localFiles = [];
      if (this.settings.syncWholeVault) {
        const allFiles = this.app.vault.getFiles();
        localFiles = allFiles.filter((file) => this.shouldSyncFileType(file));
      } else {
        for (const folderPath of this.settings.syncFolders) {
          const folder = this.app.vault.getAbstractFileByPath(folderPath);
          if (folder && folder instanceof import_obsidian.TFolder) {
            const folderFiles = await this.collectFilesToSync(folder, this.settings.includeSubfolders);
            localFiles.push(...folderFiles);
          }
        }
      }
      const driveFiles = await this.getAllFilesFromDrive(driveFolder.id);
      const localFileMap = /* @__PURE__ */ new Map();
      localFiles.forEach((file) => localFileMap.set(file.path, file));
      const driveFileMap = /* @__PURE__ */ new Map();
      driveFiles.forEach((file) => driveFileMap.set(file.path, file));
      const allPaths = /* @__PURE__ */ new Set([...localFileMap.keys(), ...driveFileMap.keys()]);
      for (const filePath of allPaths) {
        const localFile = localFileMap.get(filePath);
        const driveFile = driveFileMap.get(filePath);
        try {
          if (localFile && driveFile) {
            await this.resolveFileConflict(localFile, driveFile, driveFolder.id, result);
          } else if (localFile && !driveFile) {
            await this.uploadSingleFile(localFile, driveFolder.id, result);
          } else if (!localFile && driveFile) {
            await this.downloadFileFromDrive(driveFile, result);
          }
        } catch (error) {
          console.error(`Error syncing file ${filePath}:`, error);
          result.errors++;
        }
      }
      this.settings.lastSyncTime = Date.now();
      await this.saveSettings();
    } catch (error) {
      console.error("Bidirectional sync error:", error);
      result.errors++;
    }
    return result;
  }
  // Google Drive에서 파일 다운로드
  async downloadFileFromDrive(driveFile, result) {
    try {
      const filePath = driveFile.path;
      const localFile = this.app.vault.getAbstractFileByPath(filePath);
      if (localFile instanceof import_obsidian.TFile) {
        const needsUpdate = await this.shouldDownloadFile(localFile, driveFile);
        if (!needsUpdate) {
          result.skipped++;
          return;
        }
      }
      const content = await this.getFileContentFromDrive(driveFile.id);
      const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
      if (folderPath && this.settings.createMissingFolders) {
        await this.createLocalFolderStructure(folderPath, result);
      }
      const remoteModTime = new Date(driveFile.modifiedTime).getTime();
      if (localFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(localFile, content);
        console.log(`\u{1F504} Updated local file: ${filePath}`);
      } else {
        await this.app.vault.create(filePath, content);
        console.log(`\u{1F4E5} Downloaded new file: ${filePath}`);
      }
      await this.syncFileTime(filePath, remoteModTime);
      result.downloaded++;
    } catch (error) {
      console.error(`Error downloading file ${driveFile.path}:`, error);
      throw error;
    }
  }
  // 파일 시간 동기화 메서드 - 대안 방법들 포함
  async syncFileTime(filePath, targetTime) {
    try {
      const adapter = this.app.vault.adapter;
      if (adapter.constructor.name === "FileSystemAdapter") {
        try {
          const fs = require("fs").promises;
          const path = require("path");
          const fullPath = path.join(adapter.basePath, filePath);
          const targetDate = new Date(targetTime);
          await fs.utimes(fullPath, targetDate, targetDate);
          console.log(`\u23F0 Synced file time: ${filePath} -> ${targetDate.toLocaleString()}`);
          return;
        } catch (fsError) {
          console.warn(`\u26A0\uFE0F Direct filesystem access failed: ${fsError}`);
        }
      }
      try {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian.TFile) {
          if (file.stat && file.stat.mtime !== void 0) {
            file.stat.mtime = targetTime;
            console.log(`\u23F0 Updated file stat time: ${filePath} -> ${new Date(targetTime).toLocaleString()}`);
            return;
          }
        }
      } catch (obsidianError) {
        console.warn(`\u26A0\uFE0F Obsidian API time sync failed: ${obsidianError}`);
      }
      try {
        const timeMetadata = {
          originalPath: filePath,
          remoteModifiedTime: targetTime,
          syncedAt: Date.now()
        };
        const metadataPath = `.obsidian/plugins/gdrive-sync/time-metadata/${filePath.replace(/[\/\\]/g, "_")}.json`;
        const metadataDir = metadataPath.substring(0, metadataPath.lastIndexOf("/"));
        try {
          await this.app.vault.createFolder(metadataDir);
        } catch (e) {
        }
        await this.app.vault.create(metadataPath, JSON.stringify(timeMetadata, null, 2));
        console.log(`\u23F0 Stored time metadata: ${filePath} -> ${new Date(targetTime).toLocaleString()}`);
      } catch (metadataError) {
        console.warn(`\u26A0\uFE0F Metadata time storage failed: ${metadataError}`);
      }
    } catch (error) {
      console.warn(`\u26A0\uFE0F All file time sync methods failed for ${filePath}:`, error);
    }
  }
  // 메타데이터에서 시간 정보를 읽어오는 헬퍼 메서드
  async getStoredFileTime(filePath) {
    try {
      const metadataPath = `.obsidian/plugins/gdrive-sync/time-metadata/${filePath.replace(/[\/\\]/g, "_")}.json`;
      const metadataFile = this.app.vault.getAbstractFileByPath(metadataPath);
      if (metadataFile instanceof import_obsidian.TFile) {
        const content = await this.app.vault.read(metadataFile);
        const metadata = JSON.parse(content);
        return metadata.remoteModifiedTime || null;
      }
    } catch (error) {
    }
    return null;
  }
  // 로컬 폴더 구조 생성
  async createLocalFolderStructure(folderPath, result) {
    if (!folderPath)
      return;
    const pathParts = folderPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const existingFolder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!existingFolder) {
        try {
          await this.app.vault.createFolder(currentPath);
          console.log(`\u{1F4C1} Created local folder: ${currentPath}`);
          result.createdFolders.push(currentPath);
        } catch (error) {
          if (!error.message.includes("already exists")) {
            throw error;
          }
        }
      }
    }
  }
  // 파일 충돌 해결
  async resolveFileConflict(localFile, driveFile, rootFolderId, result) {
    const localModTime = localFile.stat.mtime;
    const remoteModTime = new Date(driveFile.modifiedTime).getTime();
    let resolution;
    switch (this.settings.conflictResolution) {
      case "local":
        resolution = "local";
        break;
      case "remote":
        resolution = "remote";
        break;
      case "newer":
        resolution = localModTime > remoteModTime ? "local" : "remote";
        break;
      case "ask":
        resolution = localModTime > remoteModTime ? "local" : "remote";
        console.log(`Conflict resolved automatically (newer): ${localFile.path} -> ${resolution}`);
        break;
    }
    if (resolution === "local") {
      await this.uploadSingleFile(localFile, rootFolderId, result);
    } else {
      await this.downloadFileFromDrive(driveFile, result);
    }
    result.conflicts++;
  }
  // 단일 파일 업로드
  async uploadSingleFile(file, rootFolderId, result) {
    try {
      const syncResult = await this.syncFileToGoogleDrive(file, rootFolderId);
      if (syncResult === "skipped") {
        result.skipped++;
      } else if (syncResult === true) {
        result.uploaded++;
      } else {
        result.errors++;
      }
    } catch (error) {
      console.error(`Error uploading file ${file.path}:`, error);
      result.errors++;
    }
  }
  // 여러 파일 업로드
  async uploadFilesToDrive(filesToSync, rootFolderId, result) {
    for (const file of filesToSync) {
      await this.uploadSingleFile(file, rootFolderId, result);
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  // Google Drive에서 모든 파일 가져오기 (재귀적으로 폴더 구조 포함) - public으로 변경
  async getAllFilesFromDrive(folderId, basePath = "") {
    const allFiles = [];
    try {
      let pageToken = "";
      do {
        const query = `'${folderId}' in parents and trashed=false`;
        const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,modifiedTime,size,parents)&pageSize=1000${pageToken ? `&pageToken=${pageToken}` : ""}`;
        const response = await (0, import_obsidian.requestUrl)({
          url,
          method: "GET",
          headers: {
            "Authorization": `Bearer ${this.settings.accessToken}`
          },
          throw: false
        });
        if (response.status !== 200) {
          console.error("Failed to list files:", response.status, response.json);
          break;
        }
        const data = response.json;
        for (const file of data.files || []) {
          const filePath = basePath ? `${basePath}/${file.name}` : file.name;
          if (file.mimeType === "application/vnd.google-apps.folder") {
            if (this.settings.includeSubfolders) {
              const subFiles = await this.getAllFilesFromDrive(file.id, filePath);
              allFiles.push(...subFiles);
            }
          } else {
            allFiles.push({
              ...file,
              path: filePath
            });
          }
        }
        pageToken = data.nextPageToken || "";
      } while (pageToken);
    } catch (error) {
      console.error("Error getting files from Drive:", error);
      throw error;
    }
    return allFiles;
  }
  // 파일 다운로드 필요 여부 판단
  async shouldDownloadFile(localFile, driveFile) {
    switch (this.settings.syncMode) {
      case "always":
        return true;
      case "modified":
        const localModTime = localFile.stat.mtime;
        const driveModTime = new Date(driveFile.modifiedTime).getTime();
        const storedRemoteTime = await this.getStoredFileTime(localFile.path);
        if (storedRemoteTime && storedRemoteTime === driveModTime) {
          return false;
        }
        return driveModTime > localModTime;
      case "checksum":
        try {
          const localContent = await this.app.vault.read(localFile);
          const localHash = await this.calculateFileHash(localContent);
          const driveContent = await this.getFileContentFromDrive(driveFile.id);
          const driveHash = await this.calculateFileHash(driveContent);
          return localHash !== driveHash;
        } catch (error) {
          console.error("Error comparing file checksums:", error);
          return true;
        }
      default:
        return true;
    }
  }
  // 동기화 결과 객체 생성
  createEmptyResult() {
    return {
      uploaded: 0,
      downloaded: 0,
      skipped: 0,
      conflicts: 0,
      errors: 0,
      createdFolders: []
    };
  }
  // 동기화 결과 보고
  reportSyncResult(result) {
    const messages = [];
    if (result.uploaded > 0)
      messages.push(`${result.uploaded} uploaded`);
    if (result.downloaded > 0)
      messages.push(`${result.downloaded} downloaded`);
    if (result.skipped > 0)
      messages.push(`${result.skipped} skipped`);
    if (result.conflicts > 0)
      messages.push(`${result.conflicts} conflicts resolved`);
    if (result.createdFolders.length > 0)
      messages.push(`${result.createdFolders.length} folders created`);
    const summary = messages.length > 0 ? messages.join(", ") : "No changes";
    if (result.errors === 0) {
      new import_obsidian.Notice(`\u2705 Sync completed: ${summary}`);
    } else {
      new import_obsidian.Notice(`\u26A0\uFE0F Sync completed with ${result.errors} errors: ${summary}`);
    }
    if (result.createdFolders.length > 0) {
      console.log("Created folders:", result.createdFolders);
    }
  }
  // 기존 메서드들 (syncVault, syncFolder 등은 새로운 구조에 맞게 수정)
  async syncVault() {
    return await this.syncWithGoogleDrive();
  }
  async syncFolder(folder) {
    const originalSyncWholeVault = this.settings.syncWholeVault;
    const originalSyncFolders = [...this.settings.syncFolders];
    this.settings.syncWholeVault = false;
    this.settings.syncFolders = [folder.path];
    try {
      const result = await this.syncWithGoogleDrive();
      return result;
    } finally {
      this.settings.syncWholeVault = originalSyncWholeVault;
      this.settings.syncFolders = originalSyncFolders;
    }
  }
  // 파일 수집 메서드 (기존과 동일)
  async collectFilesToSync(folder, includeSubfolders) {
    const files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile) {
        if (this.shouldSyncFileType(child)) {
          files.push(child);
        }
      } else if (child instanceof import_obsidian.TFolder && includeSubfolders) {
        const subfolderFiles = await this.collectFilesToSync(child, true);
        files.push(...subfolderFiles);
      }
    }
    return files;
  }
  getAllFolders() {
    const folders = [];
    const rootFolder = this.app.vault.getRoot();
    folders.push(rootFolder);
    const allFolders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian.TFolder);
    folders.push(...allFolders);
    return folders.sort((a, b) => a.path.localeCompare(b.path));
  }
  shouldSyncFileType(file) {
    const syncExtensions = [".md", ".txt", ".json", ".csv", ".html", ".css", ".js"];
    const excludePatterns = [
      /^\./,
      // 숨김 파일
      /\.tmp$/,
      // 임시 파일
      /\.bak$/,
      // 백업 파일
      /\.lock$/
      // 락 파일
    ];
    const hasValidExtension = syncExtensions.some((ext) => file.name.endsWith(ext));
    const shouldExclude = excludePatterns.some((pattern) => pattern.test(file.name));
    return hasValidExtension && !shouldExclude;
  }
  // Google Drive 관련 메서드들 - public으로 변경하여 설정 탭에서 접근 가능
  async getOrCreateDriveFolder() {
    try {
      console.log(`Looking for Google Drive folder: ${this.settings.driveFolder}`);
      const searchResponse = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${this.settings.driveFolder}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (searchResponse.status === 200) {
        const searchData = searchResponse.json;
        if (searchData.files && searchData.files.length > 0) {
          const folder = searchData.files[0];
          console.log(`\u2713 Found existing folder: ${folder.name} (${folder.id})`);
          return { id: folder.id, name: folder.name };
        }
      }
      console.log(`Creating new Google Drive folder: ${this.settings.driveFolder}`);
      const createResponse = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/files",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: this.settings.driveFolder,
          mimeType: "application/vnd.google-apps.folder"
        }),
        throw: false
      });
      if (createResponse.status === 200 || createResponse.status === 201) {
        const folderData = createResponse.json;
        console.log(`\u2713 Created new folder: ${folderData.name} (${folderData.id})`);
        return { id: folderData.id, name: folderData.name };
      } else {
        console.error("Failed to create folder:", createResponse.status, createResponse.json);
        return null;
      }
    } catch (error) {
      console.error("Error managing Drive folder:", error);
      return null;
    }
  }
  async syncFileToGoogleDrive(file, rootFolderId) {
    try {
      let relativePath = file.path;
      let fileName = file.name;
      let targetFolderId = rootFolderId;
      if (relativePath.includes("/")) {
        const pathParts = relativePath.split("/");
        fileName = pathParts.pop();
        const folderPath = pathParts.join("/");
        console.log(`Creating full folder structure: ${folderPath}`);
        targetFolderId = await this.createNestedFolders(folderPath, rootFolderId);
        if (!targetFolderId) {
          console.error(`Failed to create folder structure for: ${folderPath}`);
          return false;
        }
      }
      const existingFile = await this.findFileInDrive(fileName, targetFolderId);
      const needsSync = await this.shouldSyncFile(file, existingFile);
      if (!needsSync) {
        console.log(`\u23ED\uFE0F Skipping ${file.path} (no changes detected)`);
        return "skipped";
      }
      const content = await this.app.vault.read(file);
      const localModTime = file.stat.mtime;
      if (existingFile) {
        console.log(`\u{1F504} Updating ${file.path}`);
        return await this.updateFileInDrive(existingFile.id, content, localModTime);
      } else {
        console.log(`\u{1F4E4} Uploading ${file.path}`);
        return await this.uploadFileToDrive(fileName, content, targetFolderId, localModTime);
      }
    } catch (error) {
      console.error(`Error syncing file ${file.path}:`, error);
      return false;
    }
  }
  async shouldSyncFile(localFile, driveFile) {
    switch (this.settings.syncMode) {
      case "always":
        return true;
      case "modified":
        if (!driveFile) {
          return true;
        }
        const localModTime = localFile.stat.mtime;
        const driveModTime = new Date(driveFile.modifiedTime).getTime();
        return localModTime > driveModTime;
      case "checksum":
        if (!driveFile) {
          return true;
        }
        try {
          const localContent = await this.app.vault.read(localFile);
          const localHash = await this.calculateFileHash(localContent);
          const driveContent = await this.getFileContentFromDrive(driveFile.id);
          const driveHash = await this.calculateFileHash(driveContent);
          return localHash !== driveHash;
        } catch (error) {
          console.error("Error comparing file checksums:", error);
          return true;
        }
      default:
        return true;
    }
  }
  async calculateFileHash(content) {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async getFileContentFromDrive(fileId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode(response.arrayBuffer);
      } else {
        throw new Error(`Failed to download file: ${response.status}`);
      }
    } catch (error) {
      console.error("Error downloading file from Drive:", error);
      throw error;
    }
  }
  async createNestedFolders(folderPath, rootFolderId) {
    const pathParts = folderPath.split("/");
    let currentFolderId = rootFolderId;
    for (const folderName of pathParts) {
      if (!folderName)
        continue;
      const existingFolder = await this.findFolderInDrive(folderName, currentFolderId);
      if (existingFolder) {
        currentFolderId = existingFolder.id;
        console.log(`\u2713 Found existing folder: ${folderName}`);
      } else {
        const newFolder = await this.createFolderInDrive(folderName, currentFolderId);
        if (!newFolder) {
          throw new Error(`Failed to create folder: ${folderName}`);
        }
        currentFolderId = newFolder.id;
        console.log(`\u{1F4C1} Created folder: ${folderName}`);
      }
    }
    return currentFolderId;
  }
  async findFolderInDrive(folderName, parentFolderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${folderName}' and '${parentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false&fields=files(id,name)`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.files && data.files.length > 0) {
          return data.files[0];
        }
      }
      return null;
    } catch (error) {
      console.error("Error searching folder in Drive:", error);
      return null;
    }
  }
  async createFolderInDrive(folderName, parentFolderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/files",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: folderName,
          mimeType: "application/vnd.google-apps.folder",
          parents: [parentFolderId]
        }),
        throw: false
      });
      if (response.status === 200 || response.status === 201) {
        const folderData = response.json;
        return { id: folderData.id, name: folderData.name };
      } else {
        console.error("Failed to create folder:", response.status, response.json);
        return null;
      }
    } catch (error) {
      console.error("Error creating folder in Drive:", error);
      return null;
    }
  }
  async findFileInDrive(fileName, folderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${fileName}' and '${folderId}' in parents and trashed=false&fields=files(id,name,modifiedTime)`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.files && data.files.length > 0) {
          return data.files[0];
        }
      }
      return null;
    } catch (error) {
      console.error("Error searching file in Drive:", error);
      return null;
    }
  }
  async uploadFileToDrive(fileName, content, folderId, localModTime) {
    try {
      const metadata = {
        name: fileName,
        parents: [folderId],
        // 로컬 파일의 수정 시간을 Google Drive에도 반영
        modifiedTime: localModTime ? new Date(localModTime).toISOString() : void 0
      };
      const boundary = "-------314159265358979323846";
      const delimiter = "\r\n--" + boundary + "\r\n";
      const close_delim = "\r\n--" + boundary + "--";
      let body = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + "Content-Type: text/plain\r\n\r\n" + content + close_delim;
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": `multipart/related; boundary="${boundary}"`
        },
        body,
        throw: false
      });
      return response.status === 200 || response.status === 201;
    } catch (error) {
      console.error("Error uploading file to Drive:", error);
      return false;
    }
  }
  async updateFileInDrive(fileId, content, localModTime) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`,
        method: "PATCH",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "text/plain"
        },
        body: content,
        throw: false
      });
      return response.status === 200;
    } catch (error) {
      console.error("Error updating file in Drive:", error);
      return false;
    }
  }
  setupAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    this.syncIntervalId = window.setInterval(() => {
      this.syncWithGoogleDrive();
    }, this.settings.syncInterval);
  }
  resetGoogleAPIState() {
    console.log("Resetting Google API state...");
    this.isGoogleApiLoaded = false;
    console.log("Google API state reset completed");
  }
  async testDriveAPIConnection() {
    var _a;
    try {
      if (!this.settings.accessToken) {
        console.log("No access token available for testing");
        new import_obsidian.Notice("\u274C Please authenticate first");
        return false;
      }
      console.log("Testing Google Drive API connection...");
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/about?fields=user",
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      console.log("API Response Status:", response.status);
      if (response.status === 200) {
        const data = response.json;
        console.log("Drive API test successful:", data);
        new import_obsidian.Notice(`\u2705 Drive API connection successful. User: ${((_a = data.user) == null ? void 0 : _a.displayName) || "Unknown"}`);
        return true;
      } else if (response.status === 401) {
        console.error("Authentication failed - Token expired or invalid");
        new import_obsidian.Notice("\u274C Authentication expired. Please sign in again.");
        this.settings.accessToken = "";
        await this.saveSettings();
        new import_obsidian.Notice('Click "1. Open Auth URL" again to re-authenticate.');
        return false;
      } else if (response.status === 403) {
        console.error("API access denied - Check API key and permissions");
        new import_obsidian.Notice("\u274C API access denied. Check your API Key and Drive API is enabled.");
        return false;
      } else {
        console.error(`Drive API test failed: ${response.status}`);
        new import_obsidian.Notice(`\u274C Drive API connection failed (Status: ${response.status}). Check console for details.`);
        return false;
      }
    } catch (error) {
      console.error("Drive API test error:", error);
      new import_obsidian.Notice("\u274C Unexpected error occurred. Check console for details.");
      return false;
    }
  }
};
var GDriveSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Google Drive Bidirectional Sync Settings" });
    containerEl.createEl("h3", { text: "Google Drive API Configuration" });
    new import_obsidian.Setting(containerEl).setName("Client ID").setDesc("Google Drive API Client ID (Desktop Application type)").addText((text) => text.setPlaceholder("Enter your Client ID").setValue(this.plugin.settings.clientId).onChange(async (value) => {
      this.plugin.settings.clientId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Client Secret").setDesc("Google Drive API Client Secret (from Google Cloud Console)").addText((text) => text.setPlaceholder("Enter your Client Secret").setValue(this.plugin.settings.clientSecret).onChange(async (value) => {
      this.plugin.settings.clientSecret = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Google Drive API Key (from Google Cloud Console)").addText((text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Sync Configuration" });
    new import_obsidian.Setting(containerEl).setName("Google Drive Folder").setDesc("Name of the folder to create/use in Google Drive").addText((text) => text.setPlaceholder("e.g., Obsidian-Sync").setValue(this.plugin.settings.driveFolder).onChange(async (value) => {
      this.plugin.settings.driveFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Direction").setDesc("Choose how files should be synchronized").addDropdown((dropdown) => dropdown.addOption("bidirectional", "\u{1F504} Bidirectional (Upload & Download)").addOption("upload", "\u{1F4E4} Upload Only (Local \u2192 Drive)").addOption("download", "\u{1F4E5} Download Only (Drive \u2192 Local)").setValue(this.plugin.settings.syncDirection).onChange(async (value) => {
      this.plugin.settings.syncDirection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Conflict Resolution").setDesc("How to handle conflicts when both local and remote files exist").addDropdown((dropdown) => dropdown.addOption("newer", "\u{1F552} Use Newer File (recommended)").addOption("local", "\u{1F4F1} Always Use Local File").addOption("remote", "\u2601\uFE0F Always Use Remote File").addOption("ask", "\u2753 Ask User (manual resolution)").setValue(this.plugin.settings.conflictResolution).onChange(async (value) => {
      this.plugin.settings.conflictResolution = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Create Missing Folders").setDesc("Automatically create local folders when downloading files from Google Drive").addToggle((toggle) => toggle.setValue(this.plugin.settings.createMissingFolders).onChange(async (value) => {
      this.plugin.settings.createMissingFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Whole Vault").setDesc("Enable to sync the entire vault instead of selected folders").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncWholeVault).onChange(async (value) => {
      this.plugin.settings.syncWholeVault = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (!this.plugin.settings.syncWholeVault) {
      const syncFoldersSection = containerEl.createEl("div", { cls: "sync-folders-section" });
      syncFoldersSection.createEl("h4", { text: "Sync Folders" });
      const currentFoldersEl = syncFoldersSection.createEl("div", { cls: "current-folders" });
      this.updateCurrentFoldersDisplay(currentFoldersEl);
      new import_obsidian.Setting(syncFoldersSection).setName("Add Sync Folder").setDesc("Select folders to sync with Google Drive").addButton((button) => button.setButtonText("Select Folder").setCta().onClick(() => {
        this.openFolderSelector();
      }));
      new import_obsidian.Setting(syncFoldersSection).setName("Clear All Folders").setDesc("Remove all selected sync folders").addButton((button) => button.setButtonText("Clear All").setWarning().onClick(async () => {
        this.plugin.settings.syncFolders = [];
        await this.plugin.saveSettings();
        this.updateCurrentFoldersDisplay(currentFoldersEl);
        new import_obsidian.Notice("All sync folders cleared");
      }));
    }
    new import_obsidian.Setting(containerEl).setName("Include Subfolders").setDesc("Sync files from subfolders recursively").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeSubfolders).onChange(async (value) => {
      this.plugin.settings.includeSubfolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync at regular intervals").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.setupAutoSync();
      } else if (this.plugin.syncIntervalId) {
        window.clearInterval(this.plugin.syncIntervalId);
        this.plugin.syncIntervalId = null;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("How often to sync (in minutes)").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.syncInterval / 6e4).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.syncInterval = value * 6e4;
      await this.plugin.saveSettings();
      if (this.plugin.settings.autoSync) {
        this.plugin.setupAutoSync();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Mode").setDesc("How to determine if files need to be synced").addDropdown((dropdown) => dropdown.addOption("always", "Always sync (force upload)").addOption("modified", "Modified time comparison (recommended)").addOption("checksum", "Content checksum comparison (most accurate)").setValue(this.plugin.settings.syncMode).onChange(async (value) => {
      this.plugin.settings.syncMode = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Authentication" });
    new import_obsidian.Setting(containerEl).setName("Check Configuration").setDesc("Verify that Client ID, Client Secret, and API Key are properly configured").addButton((button) => button.setButtonText("Check").onClick(() => {
      if (!this.plugin.settings.clientId || !this.plugin.settings.clientSecret || !this.plugin.settings.apiKey) {
        new import_obsidian.Notice("\u274C Please set Client ID, Client Secret, and API Key");
      } else {
        new import_obsidian.Notice("\u2705 Configuration looks good! You can now authenticate.");
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Desktop App Authentication").setDesc("Authenticate with Google Drive using Desktop Application Client ID").addButton((button) => button.setButtonText("1. Open Auth URL").setCta().onClick(async () => {
      if (!this.plugin.settings.clientId || !this.plugin.settings.clientSecret) {
        new import_obsidian.Notice("\u274C Please set Client ID and Client Secret first");
        return;
      }
      await this.plugin.authenticateGoogleDrive();
    }));
    new import_obsidian.Setting(containerEl).setName("Authorization Code").setDesc("Step 2: After authentication, paste the authorization code here").addText((text) => text.setPlaceholder("Paste authorization code here...").setValue("").onChange(async (value) => {
    })).addButton((button) => button.setButtonText("2. Exchange for Token").setCta().onClick(async (evt) => {
      var _a;
      const textInput = containerEl.querySelector('input[placeholder="Paste authorization code here..."]');
      const authCode = (_a = textInput == null ? void 0 : textInput.value) == null ? void 0 : _a.trim();
      if (!authCode) {
        new import_obsidian.Notice("\u274C Please enter authorization code first");
        return;
      }
      console.log("Attempting to exchange authorization code...");
      const success = await this.plugin.exchangeCodeForToken(authCode);
      if (success) {
        if (textInput)
          textInput.value = "";
        setTimeout(async () => {
          await this.plugin.testDriveAPIConnection();
        }, 1e3);
      }
    }));
    containerEl.createEl("h3", { text: "Sync Actions" });
    new import_obsidian.Setting(containerEl).setName("Full Bidirectional Sync").setDesc("Perform complete bidirectional synchronization (upload new/changed local files, download new/changed remote files)").addButton((button) => button.setButtonText("\u{1F504} Sync Both Ways").setCta().onClick(async () => {
      const originalDirection = this.plugin.settings.syncDirection;
      this.plugin.settings.syncDirection = "bidirectional";
      try {
        await this.plugin.syncWithGoogleDrive();
      } finally {
        this.plugin.settings.syncDirection = originalDirection;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Upload to Google Drive").setDesc("Upload only: Send local files to Google Drive (one-way sync)").addButton((button) => button.setButtonText("\u{1F4E4} Upload Only").onClick(async () => {
      const originalDirection = this.plugin.settings.syncDirection;
      this.plugin.settings.syncDirection = "upload";
      try {
        await this.plugin.syncWithGoogleDrive();
      } finally {
        this.plugin.settings.syncDirection = originalDirection;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Download from Google Drive").setDesc("Download only: Get files from Google Drive to local vault (one-way sync)").addButton((button) => button.setButtonText("\u{1F4E5} Download Only").onClick(async () => {
      const originalDirection = this.plugin.settings.syncDirection;
      this.plugin.settings.syncDirection = "download";
      try {
        await this.plugin.syncWithGoogleDrive();
      } finally {
        this.plugin.settings.syncDirection = originalDirection;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Preview Sync").setDesc("Show what files would be synced (without actually syncing)").addButton((button) => button.setButtonText("Preview").onClick(async () => {
      await this.previewSync();
    }));
    containerEl.createEl("h3", { text: "Testing & Debugging" });
    new import_obsidian.Setting(containerEl).setName("Test API Connection").setDesc("Test your current access token with Google Drive API").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      await this.plugin.testDriveAPIConnection();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug Token").setDesc("Show current token status and validity").addButton((button) => button.setButtonText("Debug").onClick(async () => {
      if (!this.plugin.settings.accessToken) {
        new import_obsidian.Notice("\u274C No access token stored");
        return;
      }
      console.log("=== TOKEN DEBUG INFO ===");
      console.log("Token exists:", !!this.plugin.settings.accessToken);
      console.log("Token length:", this.plugin.settings.accessToken.length);
      console.log("Token preview:", this.plugin.settings.accessToken.substring(0, 20) + "...");
      const tokenParts = this.plugin.settings.accessToken.split(".");
      console.log("Token format:", tokenParts.length === 3 ? "JWT" : "Bearer");
      new import_obsidian.Notice(`Token info logged to console. Length: ${this.plugin.settings.accessToken.length}`);
    }));
    new import_obsidian.Setting(containerEl).setName("Manual Token Input").setDesc("Manually enter access token for testing (temporary solution)").addText((text) => text.setPlaceholder("Paste access token here...").setValue("").onChange(async (value) => {
    })).addButton((button) => button.setButtonText("Test Token").onClick(async (evt) => {
      var _a;
      const textInput = containerEl.querySelector('input[placeholder="Paste access token here..."]');
      const tempToken = (_a = textInput == null ? void 0 : textInput.value) == null ? void 0 : _a.trim();
      if (!tempToken) {
        new import_obsidian.Notice("\u274C Please enter a token first");
        return;
      }
      const originalToken = this.plugin.settings.accessToken;
      this.plugin.settings.accessToken = tempToken;
      console.log("Testing with manual token...");
      const testResult = await this.plugin.testDriveAPIConnection();
      if (testResult) {
        new import_obsidian.Notice("\u2705 Manual token works! You can save it.");
        const saveToken = confirm("Token works! Do you want to save it to settings?");
        if (saveToken) {
          await this.plugin.saveSettings();
          new import_obsidian.Notice("Token saved to settings.");
        } else {
          this.plugin.settings.accessToken = originalToken;
        }
      } else {
        this.plugin.settings.accessToken = originalToken;
        new import_obsidian.Notice("\u274C Manual token test failed.");
      }
      if (textInput)
        textInput.value = "";
    }));
    new import_obsidian.Setting(containerEl).setName("Reset API State").setDesc("Reset Google API state if you encounter issues").addButton((button) => button.setButtonText("Reset").setWarning().onClick(() => {
      this.plugin.resetGoogleAPIState();
      new import_obsidian.Notice("Google API state reset. You may need to re-authenticate.");
    }));
    new import_obsidian.Setting(containerEl).setName("Sign Out").setDesc("Revoke Google Drive access and sign out").addButton((button) => button.setButtonText("Sign Out").setWarning().onClick(async () => {
      await this.plugin.revokeGoogleDriveAccess();
    }));
    containerEl.createEl("h3", { text: "Authentication Status" });
    const statusEl = containerEl.createEl("div");
    const updateStatus = () => {
      const isAuth = this.plugin.isAuthenticated();
      statusEl.innerHTML = `
                <div style="padding: 10px; border-radius: 4px; margin-bottom: 10px; ${isAuth ? "background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724;" : "background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24;"}">
                    <strong>Authentication:</strong> ${isAuth ? "\u2705 Authenticated" : "\u274C Not Authenticated"}
                    ${this.plugin.settings.accessToken ? "<br><small>Access token is stored</small>" : "<br><small>No access token stored</small>"}
                </div>
                <div style="padding: 10px; border-radius: 4px; background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460;">
                    <strong>Mode:</strong> \u2705 Desktop Application (Bidirectional Sync)
                    <br><small>Supports upload, download, and bidirectional synchronization with preserved folder structure</small>
                    <br><small>Sync Direction: ${this.plugin.settings.syncDirection === "bidirectional" ? "\u{1F504} Bidirectional" : this.plugin.settings.syncDirection === "upload" ? "\u{1F4E4} Upload Only" : "\u{1F4E5} Download Only"}</small>
                    <br><small>Conflict Resolution: ${this.plugin.settings.conflictResolution === "newer" ? "\u{1F552} Use Newer File" : this.plugin.settings.conflictResolution === "local" ? "\u{1F4F1} Always Use Local" : this.plugin.settings.conflictResolution === "remote" ? "\u2601\uFE0F Always Use Remote" : "\u2753 Ask User"}</small>
                </div>
            `;
    };
    updateStatus();
    const originalSaveSettings = this.plugin.saveSettings.bind(this.plugin);
    this.plugin.saveSettings = async () => {
      await originalSaveSettings();
      updateStatus();
    };
    containerEl.createEl("h3", { text: "Setup Instructions" });
    const instructionsEl = containerEl.createEl("div");
    instructionsEl.innerHTML = `
            <div style="background-color: #d4edda; border: 1px solid #c3e6cb; padding: 10px; margin: 10px 0; border-radius: 4px;">
                <p><strong>\u2705 Google Cloud Console \uC124\uC815 (Desktop Application):</strong></p>
                <ol>
                    <li><a href="https://console.cloud.google.com/apis/credentials" target="_blank">Google Cloud Console - Credentials</a> \uC811\uC18D</li>
                    <li>"Create Credentials" \u2192 "OAuth client ID" \uC120\uD0DD</li>
                    <li><strong>Application type: "Desktop application"</strong> \uC120\uD0DD (\uC911\uC694!)</li>
                    <li>Name \uC785\uB825 \uD6C4 "Create" \uD074\uB9AD</li>
                    <li>\uC0DD\uC131\uB41C <strong>Client ID</strong>\uC640 <strong>Client Secret</strong>\uC744 \uC704 \uC124\uC815\uC5D0 \uC785\uB825</li>
                    <li>Google Drive API\uAC00 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uB294\uC9C0 \uD655\uC778</li>
                </ol>
            </div>
            <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 10px; margin: 10px 0; border-radius: 4px;">
                <p><strong>\u{1F504} \uC591\uBC29\uD5A5 \uB3D9\uAE30\uD654 \uAE30\uB2A5:</strong></p>
                <ul>
                    <li><strong>\u{1F4E4} \uC5C5\uB85C\uB4DC \uC804\uC6A9:</strong> \uB85C\uCEEC \uD30C\uC77C\uC744 Google Drive\uC5D0\uB9CC \uC5C5\uB85C\uB4DC</li>
                    <li><strong>\u{1F4E5} \uB2E4\uC6B4\uB85C\uB4DC \uC804\uC6A9:</strong> Google Drive \uD30C\uC77C\uC744 \uB85C\uCEEC\uC5D0\uB9CC \uB2E4\uC6B4\uB85C\uB4DC</li>
                    <li><strong>\u{1F504} \uC591\uBC29\uD5A5 \uB3D9\uAE30\uD654:</strong> \uC591\uCABD \uBAA8\uB450 \uD655\uC778\uD558\uACE0 \uCD5C\uC2E0 \uC0C1\uD0DC\uB85C \uB3D9\uAE30\uD654</li>
                </ul>
                <p><strong>\u{1F91D} \uCDA9\uB3CC \uD574\uACB0 \uBC29\uC2DD:</strong></p>
                <ul>
                    <li><strong>Use Newer File:</strong> \uC218\uC815 \uC2DC\uAC04\uC774 \uB354 \uCD5C\uC2E0\uC778 \uD30C\uC77C \uC0AC\uC6A9 (\uAD8C\uC7A5)</li>
                    <li><strong>Always Use Local:</strong> \uD56D\uC0C1 \uB85C\uCEEC \uD30C\uC77C \uC6B0\uC120</li>
                    <li><strong>Always Use Remote:</strong> \uD56D\uC0C1 \uC6D0\uACA9 \uD30C\uC77C \uC6B0\uC120</li>
                    <li><strong>Ask User:</strong> \uC0AC\uC6A9\uC790\uC5D0\uAC8C \uC9C1\uC811 \uD655\uC778 (\uD604\uC7AC\uB294 newer\uB85C \uB3D9\uC791)</li>
                </ul>
                <p><strong>\u{1F4C1} \uC790\uB3D9 \uD3F4\uB354 \uC0DD\uC131:</strong></p>
                <ul>
                    <li>Google Drive\uC5D0\uC11C \uB2E4\uC6B4\uB85C\uB4DC \uC2DC \uB85C\uCEEC\uC5D0 \uC5C6\uB294 \uD3F4\uB354 \uC790\uB3D9 \uC0DD\uC131</li>
                    <li>\uD3F4\uB354 \uAD6C\uC870\uB97C \uC644\uC804\uD788 \uBCF4\uC874\uD558\uC5EC \uB3D9\uAE30\uD654</li>
                    <li>\uCD08\uAE30 \uC124\uC815 \uC2DC Google Drive\uC758 \uC804\uCCB4 \uAD6C\uC870\uB97C \uB85C\uCEEC\uB85C \uBCF5\uC81C \uAC00\uB2A5</li>
                </ul>
            </div>
            <div style="background-color: #e7f3ff; border: 1px solid #b3d7ff; padding: 10px; margin: 10px 0; border-radius: 4px;">
                <p><strong>\u{1F680} \uC0AC\uC6A9 \uC2DC\uB098\uB9AC\uC624:</strong></p>
                <ul>
                    <li><strong>\uCD08\uAE30 \uC124\uC815:</strong> "\u{1F4E5} Download Only"\uB85C Google Drive \uB0B4\uC6A9\uC744 \uB85C\uCEEC\uC5D0 \uBCF5\uC81C</li>
                    <li><strong>\uC77C\uC0C1 \uC791\uC5C5:</strong> "\u{1F504} Sync Both Ways"\uB85C \uC591\uBC29\uD5A5 \uB3D9\uAE30\uD654</li>
                    <li><strong>\uBC31\uC5C5:</strong> "\u{1F4E4} Upload Only"\uB85C \uB85C\uCEEC \uBCC0\uACBD\uC0AC\uD56D\uB9CC \uC5C5\uB85C\uB4DC</li>
                    <li><strong>\uBCF5\uC6D0:</strong> "\u{1F4E5} Download Only"\uB85C Google Drive\uC5D0\uC11C \uBCF5\uC6D0</li>
                </ul>
                <p><strong>\u{1F4A1} \uD301:</strong></p>
                <ul>
                    <li>\uBA3C\uC800 "Preview Sync"\uB85C \uB3D9\uAE30\uD654\uB420 \uD30C\uC77C \uD655\uC778</li>
                    <li>"Create Missing Folders" \uC635\uC158\uC73C\uB85C \uD3F4\uB354 \uAD6C\uC870 \uC790\uB3D9 \uC0DD\uC131</li>
                    <li>Auto Sync \uAE30\uB2A5\uC73C\uB85C \uC815\uAE30\uC801 \uC790\uB3D9 \uB3D9\uAE30\uD654</li>
                </ul>
            </div>
        `;
  }
  // 현재 선택된 폴더들 표시 업데이트
  updateCurrentFoldersDisplay(containerEl) {
    containerEl.empty();
    if (this.plugin.settings.syncFolders.length === 0) {
      containerEl.createEl("p", { text: "No folders selected for sync", cls: "setting-item-description" });
      return;
    }
    containerEl.createEl("p", { text: "Selected folders:", cls: "setting-item-description" });
    const folderList = containerEl.createEl("div", { cls: "sync-folders-list" });
    this.plugin.settings.syncFolders.forEach((folderPath, index) => {
      const folderItem = folderList.createEl("div", {
        cls: "sync-folder-item",
        attr: { style: "display: flex; align-items: center; margin-bottom: 5px; padding: 5px; background-color: var(--background-secondary); border-radius: 3px;" }
      });
      const folderName = folderItem.createEl("span", {
        text: folderPath || "\u{1F4C1} Vault Root",
        attr: { style: "flex-grow: 1; margin-right: 10px;" }
      });
      const removeButton = folderItem.createEl("button", {
        text: "\u2716",
        cls: "mod-warning",
        attr: { style: "min-width: 24px; height: 24px; padding: 0; border-radius: 3px;" }
      });
      removeButton.onclick = async () => {
        this.plugin.settings.syncFolders.splice(index, 1);
        await this.plugin.saveSettings();
        this.updateCurrentFoldersDisplay(containerEl);
        new import_obsidian.Notice(`Removed folder: ${folderPath || "Vault Root"}`);
      };
    });
  }
  // 폴더 선택 모달 열기
  openFolderSelector() {
    const modal = new FolderTreeModal(this.app, this.plugin, async (selectedFolder) => {
      const folderPath = selectedFolder.path;
      if (this.plugin.settings.syncFolders.includes(folderPath)) {
        new import_obsidian.Notice(`Folder "${folderPath || "Vault Root"}" is already selected`);
        return;
      }
      this.plugin.settings.syncFolders.push(folderPath);
      await this.plugin.saveSettings();
      const currentFoldersEl = document.querySelector(".current-folders");
      if (currentFoldersEl) {
        this.updateCurrentFoldersDisplay(currentFoldersEl);
      }
      new import_obsidian.Notice(`Added folder: ${folderPath || "Vault Root"}`);
    });
    modal.open();
  }
  // 동기화 미리보기 - 양방향 지원 버전
  async previewSync() {
    if (!this.plugin.isAuthenticated()) {
      new import_obsidian.Notice("\u274C Please authenticate first");
      return;
    }
    try {
      console.log("=== BIDIRECTIONAL SYNC PREVIEW ===");
      console.log(`Google Drive folder: ${this.plugin.settings.driveFolder}`);
      console.log(`Sync direction: ${this.plugin.settings.syncDirection}`);
      console.log(`Conflict resolution: ${this.plugin.settings.conflictResolution}`);
      console.log(`Include subfolders: ${this.plugin.settings.includeSubfolders}`);
      console.log(`Create missing folders: ${this.plugin.settings.createMissingFolders}`);
      console.log(`Last sync: ${this.plugin.settings.lastSyncTime ? new Date(this.plugin.settings.lastSyncTime).toLocaleString() : "Never"}`);
      let localFiles = [];
      if (this.plugin.settings.syncWholeVault) {
        const allFiles = this.plugin.app.vault.getFiles();
        localFiles = allFiles.filter((file) => this.plugin.shouldSyncFileType(file));
        console.log(`
\u{1F4F1} LOCAL FILES (Whole Vault): ${localFiles.length} files`);
      } else {
        if (this.plugin.settings.syncFolders.length === 0) {
          new import_obsidian.Notice("\u274C No folders selected for sync");
          return;
        }
        console.log(`
\u{1F4F1} LOCAL FILES (Selected Folders):`);
        for (const folderPath of this.plugin.settings.syncFolders) {
          const folder = this.plugin.app.vault.getAbstractFileByPath(folderPath);
          if (folder && folder instanceof import_obsidian.TFolder) {
            const files = await this.plugin.collectFilesToSync(folder, this.plugin.settings.includeSubfolders);
            localFiles.push(...files);
            console.log(`  \u{1F4C1} ${folderPath || "Vault Root"}: ${files.length} files`);
          }
        }
      }
      localFiles.forEach((file) => {
        const modTime = new Date(file.stat.mtime).toLocaleString();
        console.log(`    - ${file.path} (modified: ${modTime})`);
      });
      const driveFolder = await this.plugin.getOrCreateDriveFolder();
      if (!driveFolder) {
        new import_obsidian.Notice("\u274C Failed to access Google Drive folder");
        return;
      }
      const driveFiles = await this.plugin.getAllFilesFromDrive(driveFolder.id);
      console.log(`
\u2601\uFE0F GOOGLE DRIVE FILES: ${driveFiles.length} files`);
      driveFiles.forEach((file) => {
        const modTime = new Date(file.modifiedTime).toLocaleString();
        console.log(`    - ${file.path} (modified: ${modTime})`);
      });
      const localFileMap = /* @__PURE__ */ new Map();
      localFiles.forEach((file) => localFileMap.set(file.path, file));
      const driveFileMap = /* @__PURE__ */ new Map();
      driveFiles.forEach((file) => driveFileMap.set(file.path, file));
      const allPaths = /* @__PURE__ */ new Set([...localFileMap.keys(), ...driveFileMap.keys()]);
      let toUpload = 0;
      let toDownload = 0;
      let conflicts = 0;
      let skipped = 0;
      console.log(`
\u{1F50D} SYNC ANALYSIS:`);
      for (const filePath of allPaths) {
        const localFile = localFileMap.get(filePath);
        const driveFile = driveFileMap.get(filePath);
        if (localFile && driveFile) {
          const localModTime = localFile.stat.mtime;
          const driveModTime = new Date(driveFile.modifiedTime).getTime();
          if (this.plugin.settings.syncDirection === "bidirectional") {
            if (localModTime !== driveModTime) {
              conflicts++;
              console.log(`  \u26A0\uFE0F CONFLICT: ${filePath} (local: ${new Date(localModTime).toLocaleString()}, remote: ${new Date(driveModTime).toLocaleString()})`);
            } else {
              skipped++;
              console.log(`  \u23ED\uFE0F SKIP: ${filePath} (same modification time)`);
            }
          } else if (this.plugin.settings.syncDirection === "upload") {
            if (localModTime > driveModTime) {
              toUpload++;
              console.log(`  \u{1F4E4} UPLOAD: ${filePath}`);
            } else {
              skipped++;
              console.log(`  \u23ED\uFE0F SKIP: ${filePath} (remote is newer or same)`);
            }
          } else if (this.plugin.settings.syncDirection === "download") {
            if (driveModTime > localModTime) {
              toDownload++;
              console.log(`  \u{1F4E5} DOWNLOAD: ${filePath}`);
            } else {
              skipped++;
              console.log(`  \u23ED\uFE0F SKIP: ${filePath} (local is newer or same)`);
            }
          }
        } else if (localFile && !driveFile) {
          if (this.plugin.settings.syncDirection !== "download") {
            toUpload++;
            console.log(`  \u{1F4E4} UPLOAD NEW: ${filePath}`);
          } else {
            skipped++;
            console.log(`  \u23ED\uFE0F SKIP: ${filePath} (local only, download mode)`);
          }
        } else if (!localFile && driveFile) {
          if (this.plugin.settings.syncDirection !== "upload") {
            toDownload++;
            console.log(`  \u{1F4E5} DOWNLOAD NEW: ${filePath}`);
          } else {
            skipped++;
            console.log(`  \u23ED\uFE0F SKIP: ${filePath} (remote only, upload mode)`);
          }
        }
      }
      const summary = [
        `\u{1F4E4} To Upload: ${toUpload}`,
        `\u{1F4E5} To Download: ${toDownload}`,
        `\u26A0\uFE0F Conflicts: ${conflicts}`,
        `\u23ED\uFE0F Skipped: ${skipped}`,
        `\u{1F4C1} Total Files: ${allPaths.size}`
      ].join(", ");
      console.log(`
\u{1F4CB} SUMMARY: ${summary}`);
      new import_obsidian.Notice(`\u{1F4CB} Sync Preview: ${summary}. Check console for details.`);
    } catch (error) {
      console.error("Preview sync error:", error);
      new import_obsidian.Notice("\u274C Failed to preview sync. Check console for details.");
    }
  }
};
