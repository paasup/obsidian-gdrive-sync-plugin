/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GDriveSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  clientId: "",
  clientSecret: "",
  apiKey: "",
  syncFolder: "",
  autoSync: false,
  syncInterval: 3e5,
  // 5 minutes
  accessToken: "",
  driveFolder: "Obsidian-Sync",
  // 기본 Google Drive 폴더명
  includeSubfolders: true,
  // 기본적으로 하위 폴더 포함
  syncMode: "modified",
  // 기본: 수정 시간 기반
  lastSyncTime: 0
};
var GDriveSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    this.isGoogleApiLoaded = false;
  }
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon("cloud", "Google Drive Sync", (evt) => {
      this.syncWithGoogleDrive();
    });
    ribbonIconEl.addClass("gdrive-sync-ribbon-class");
    this.addCommand({
      id: "sync-with-gdrive",
      name: "Sync with Google Drive",
      callback: () => {
        this.syncWithGoogleDrive();
      }
    });
    this.addSettingTab(new GDriveSyncSettingTab(this.app, this));
    console.log("Plugin loaded - Desktop App authentication mode with folder structure preservation");
    if (this.settings.autoSync) {
      this.setupAutoSync();
    }
  }
  onunload() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async authenticateGoogleDrive() {
    console.log("=== Starting Google Drive Desktop Authentication ===");
    if (!this.settings.clientId || !this.settings.clientSecret || !this.settings.apiKey) {
      console.error("Missing credentials");
      new import_obsidian.Notice("\u274C Please set Client ID, Client Secret, and API Key in settings first.");
      return false;
    }
    console.log("\u2713 Credentials are set");
    const authUrl = this.generateAuthUrl();
    new import_obsidian.Notice("Opening browser for Desktop App authentication...");
    console.log("Desktop Auth URL:", authUrl);
    try {
      window.open(authUrl, "_blank");
      new import_obsidian.Notice('\u{1F517} Complete authentication in browser, then copy the authorization code and use "Authorization Code" input in settings.');
      return false;
    } catch (error) {
      console.error("Failed to open browser:", error);
      try {
        navigator.clipboard.writeText(authUrl);
        new import_obsidian.Notice("\u{1F4CB} Auth URL copied to clipboard. Open it in your browser.");
      } catch (clipboardError) {
        console.error("Failed to copy to clipboard:", clipboardError);
        new import_obsidian.Notice("\u274C Failed to open browser. Please check console for auth URL.");
      }
      return false;
    }
  }
  generateAuthUrl() {
    const params = new URLSearchParams({
      client_id: this.settings.clientId,
      redirect_uri: "urn:ietf:wg:oauth:2.0:oob",
      // Desktop app용 out-of-band
      scope: "https://www.googleapis.com/auth/drive.file",
      response_type: "code",
      access_type: "offline",
      prompt: "consent"
    });
    return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
  }
  async exchangeCodeForToken(authCode) {
    try {
      console.log("Exchanging authorization code for access token...");
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://oauth2.googleapis.com/token",
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          client_id: this.settings.clientId,
          client_secret: this.settings.clientSecret,
          code: authCode,
          grant_type: "authorization_code",
          redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
        }).toString(),
        throw: false
      });
      if (response.status === 200) {
        const tokenData = response.json;
        console.log("Token exchange successful");
        this.settings.accessToken = tokenData.access_token;
        await this.saveSettings();
        new import_obsidian.Notice("\u2705 Desktop App authentication successful!");
        return true;
      } else {
        console.error("Token exchange failed:", response.status, response.json);
        new import_obsidian.Notice("\u274C Failed to exchange authorization code for token.");
        return false;
      }
    } catch (error) {
      console.error("Token exchange error:", error);
      new import_obsidian.Notice("\u274C Token exchange failed. Check console for details.");
      return false;
    }
  }
  async revokeGoogleDriveAccess() {
    try {
      console.log("Revoking Google Drive access...");
      if (!this.settings.accessToken) {
        console.log("No access token to revoke");
        new import_obsidian.Notice("No active session to revoke");
        return true;
      }
      this.settings.accessToken = "";
      await this.saveSettings();
      console.log("\u2713 Google Drive access revoked successfully");
      new import_obsidian.Notice("Google Drive access revoked successfully");
      return true;
    } catch (error) {
      console.error("Failed to revoke access:", error);
      new import_obsidian.Notice("Failed to revoke access. Token cleared locally.");
      this.settings.accessToken = "";
      await this.saveSettings();
      return false;
    }
  }
  isAuthenticated() {
    return !!this.settings.accessToken;
  }
  async syncWithGoogleDrive() {
    if (!this.settings.clientId || !this.settings.clientSecret || !this.settings.apiKey) {
      new import_obsidian.Notice("Please configure Google Drive API credentials in settings");
      return;
    }
    if (!this.settings.syncFolder) {
      new import_obsidian.Notice("Please select a folder to sync in settings");
      return;
    }
    new import_obsidian.Notice("Starting Google Drive sync...");
    try {
      if (!this.isAuthenticated()) {
        new import_obsidian.Notice("Please authenticate first using the Desktop App method.");
        return;
      }
      const folder = this.app.vault.getAbstractFileByPath(this.settings.syncFolder);
      if (!folder || !(folder instanceof import_obsidian.TFolder)) {
        new import_obsidian.Notice("Sync folder not found");
        return;
      }
      await this.syncFolder(folder);
      new import_obsidian.Notice("Google Drive sync completed");
    } catch (error) {
      console.error("Sync failed:", error);
      new import_obsidian.Notice("Google Drive sync failed");
    }
  }
  async syncFolder(folder) {
    console.log(`Syncing folder: ${folder.path}`);
    console.log(`Include subfolders: ${this.settings.includeSubfolders}`);
    try {
      const driveFolder = await this.getOrCreateDriveFolder();
      if (!driveFolder) {
        new import_obsidian.Notice("\u274C Failed to create or find Google Drive folder");
        return;
      }
      console.log(`\u2713 Google Drive folder ready: ${this.settings.driveFolder}`);
      const filesToSync = await this.collectFilesToSyncPrivate(folder, this.settings.includeSubfolders);
      console.log(`Found ${filesToSync.length} files to sync`);
      if (filesToSync.length === 0) {
        new import_obsidian.Notice("No files found to sync");
        return;
      }
      let successCount = 0;
      let errorCount = 0;
      let skippedCount = 0;
      for (const file of filesToSync) {
        try {
          const result = await this.syncFileToGoogleDrive(file, driveFolder.id);
          if (result === "skipped") {
            skippedCount++;
          } else if (result === true) {
            successCount++;
          } else {
            errorCount++;
            console.error(`\u2717 Failed to sync: ${file.path}`);
          }
        } catch (error) {
          errorCount++;
          console.error(`\u2717 Error syncing ${file.path}:`, error);
        }
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      this.settings.lastSyncTime = Date.now();
      await this.saveSettings();
      if (errorCount === 0) {
        new import_obsidian.Notice(`\u2705 Sync completed: ${successCount} synced, ${skippedCount} skipped`);
      } else {
        new import_obsidian.Notice(`\u26A0\uFE0F Sync completed with errors: ${successCount} synced, ${skippedCount} skipped, ${errorCount} errors`);
      }
    } catch (error) {
      console.error("Sync folder error:", error);
      new import_obsidian.Notice("\u274C Sync failed. Check console for details.");
    }
  }
  // Public method for settings tab
  async collectFilesToSync(folder, includeSubfolders) {
    const files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile) {
        if (this.shouldSyncFileType(child)) {
          files.push(child);
        }
      } else if (child instanceof import_obsidian.TFolder && includeSubfolders) {
        const subfolderFiles = await this.collectFilesToSync(child, true);
        files.push(...subfolderFiles);
      }
    }
    return files;
  }
  // 동기화할 파일들을 수집 (하위 폴더 포함/제외 옵션)
  async collectFilesToSyncPrivate(folder, includeSubfolders) {
    return this.collectFilesToSync(folder, includeSubfolders);
  }
  // 파일이 동기화 대상인지 확인
  shouldSyncFileType(file) {
    const syncExtensions = [".md", ".txt", ".json", ".csv", ".html", ".css", ".js"];
    const excludePatterns = [
      /^\./,
      // 숨김 파일
      /\.tmp$/,
      // 임시 파일
      /\.bak$/,
      // 백업 파일
      /\.lock$/
      // 락 파일
    ];
    const hasValidExtension = syncExtensions.some((ext) => file.name.endsWith(ext));
    const shouldExclude = excludePatterns.some((pattern) => pattern.test(file.name));
    return hasValidExtension && !shouldExclude;
  }
  // Google Drive에서 Obsidian 동기화 폴더 찾기 또는 생성
  async getOrCreateDriveFolder() {
    try {
      console.log(`Looking for Google Drive folder: ${this.settings.driveFolder}`);
      const searchResponse = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${this.settings.driveFolder}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (searchResponse.status === 200) {
        const searchData = searchResponse.json;
        if (searchData.files && searchData.files.length > 0) {
          const folder = searchData.files[0];
          console.log(`\u2713 Found existing folder: ${folder.name} (${folder.id})`);
          return { id: folder.id, name: folder.name };
        }
      }
      console.log(`Creating new Google Drive folder: ${this.settings.driveFolder}`);
      const createResponse = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/files",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: this.settings.driveFolder,
          mimeType: "application/vnd.google-apps.folder"
        }),
        throw: false
      });
      if (createResponse.status === 200 || createResponse.status === 201) {
        const folderData = createResponse.json;
        console.log(`\u2713 Created new folder: ${folderData.name} (${folderData.id})`);
        return { id: folderData.id, name: folderData.name };
      } else {
        console.error("Failed to create folder:", createResponse.status, createResponse.json);
        return null;
      }
    } catch (error) {
      console.error("Error managing Drive folder:", error);
      return null;
    }
  }
  // 개별 파일을 Google Drive에 동기화
  async syncFileToGoogleDrive(file, rootFolderId) {
    try {
      const relativePath = file.path.replace(this.settings.syncFolder + "/", "");
      let targetFolderId = rootFolderId;
      let fileName = file.name;
      if (relativePath.includes("/")) {
        const pathParts = relativePath.split("/");
        fileName = pathParts.pop();
        const folderPath = pathParts.join("/");
        targetFolderId = await this.createNestedFolders(folderPath, rootFolderId);
        if (!targetFolderId) {
          console.error(`Failed to create folder structure for: ${folderPath}`);
          return false;
        }
      }
      const existingFile = await this.findFileInDrive(fileName, targetFolderId);
      const needsSync = await this.shouldSyncFile(file, existingFile);
      if (!needsSync) {
        console.log(`\u23ED\uFE0F Skipping ${file.path} (no changes detected)`);
        return "skipped";
      }
      const content = await this.app.vault.read(file);
      if (existingFile) {
        console.log(`\u{1F504} Updating ${file.path}`);
        return await this.updateFileInDrive(existingFile.id, content, file.stat.mtime);
      } else {
        console.log(`\u{1F4E4} Uploading ${file.path}`);
        return await this.uploadFileToDrive(fileName, content, targetFolderId);
      }
    } catch (error) {
      console.error(`Error syncing file ${file.path}:`, error);
      return false;
    }
  }
  // 파일 동기화 필요 여부 판단
  async shouldSyncFile(localFile, driveFile) {
    switch (this.settings.syncMode) {
      case "always":
        return true;
      case "modified":
        if (!driveFile) {
          return true;
        }
        const localModTime = localFile.stat.mtime;
        const driveModTime = new Date(driveFile.modifiedTime).getTime();
        return localModTime > driveModTime;
      case "checksum":
        if (!driveFile) {
          return true;
        }
        try {
          const localContent = await this.app.vault.read(localFile);
          const localHash = await this.calculateFileHash(localContent);
          const driveContent = await this.getFileContentFromDrive(driveFile.id);
          const driveHash = await this.calculateFileHash(driveContent);
          return localHash !== driveHash;
        } catch (error) {
          console.error("Error comparing file checksums:", error);
          return true;
        }
      default:
        return true;
    }
  }
  // 파일 해시 계산 (SHA-256)
  async calculateFileHash(content) {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  // Google Drive에서 파일 내용 가져오기
  async getFileContentFromDrive(fileId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode(response.arrayBuffer);
      } else {
        throw new Error(`Failed to download file: ${response.status}`);
      }
    } catch (error) {
      console.error("Error downloading file from Drive:", error);
      throw error;
    }
  }
  // 중첩된 폴더 구조 생성
  async createNestedFolders(folderPath, rootFolderId) {
    const pathParts = folderPath.split("/");
    let currentFolderId = rootFolderId;
    for (const folderName of pathParts) {
      if (!folderName)
        continue;
      const existingFolder = await this.findFolderInDrive(folderName, currentFolderId);
      if (existingFolder) {
        currentFolderId = existingFolder.id;
        console.log(`\u2713 Found existing folder: ${folderName}`);
      } else {
        const newFolder = await this.createFolderInDrive(folderName, currentFolderId);
        if (!newFolder) {
          throw new Error(`Failed to create folder: ${folderName}`);
        }
        currentFolderId = newFolder.id;
        console.log(`\u{1F4C1} Created folder: ${folderName}`);
      }
    }
    return currentFolderId;
  }
  // Google Drive에서 폴더 검색
  async findFolderInDrive(folderName, parentFolderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${folderName}' and '${parentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false&fields=files(id,name)`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.files && data.files.length > 0) {
          return data.files[0];
        }
      }
      return null;
    } catch (error) {
      console.error("Error searching folder in Drive:", error);
      return null;
    }
  }
  // Google Drive에 새 폴더 생성
  async createFolderInDrive(folderName, parentFolderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/files",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: folderName,
          mimeType: "application/vnd.google-apps.folder",
          parents: [parentFolderId]
        }),
        throw: false
      });
      if (response.status === 200 || response.status === 201) {
        const folderData = response.json;
        return { id: folderData.id, name: folderData.name };
      } else {
        console.error("Failed to create folder:", response.status, response.json);
        return null;
      }
    } catch (error) {
      console.error("Error creating folder in Drive:", error);
      return null;
    }
  }
  // Google Drive에서 파일 검색
  async findFileInDrive(fileName, folderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${fileName}' and '${folderId}' in parents and trashed=false&fields=files(id,name,modifiedTime)`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.files && data.files.length > 0) {
          return data.files[0];
        }
      }
      return null;
    } catch (error) {
      console.error("Error searching file in Drive:", error);
      return null;
    }
  }
  // Google Drive에 새 파일 업로드
  async uploadFileToDrive(fileName, content, folderId) {
    try {
      const metadata = {
        name: fileName,
        parents: [folderId]
      };
      const boundary = "-------314159265358979323846";
      const delimiter = "\r\n--" + boundary + "\r\n";
      const close_delim = "\r\n--" + boundary + "--";
      let body = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + "Content-Type: text/plain\r\n\r\n" + content + close_delim;
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": `multipart/related; boundary="${boundary}"`
        },
        body,
        throw: false
      });
      return response.status === 200 || response.status === 201;
    } catch (error) {
      console.error("Error uploading file to Drive:", error);
      return false;
    }
  }
  // Google Drive의 기존 파일 업데이트
  async updateFileInDrive(fileId, content, localModTime) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`,
        method: "PATCH",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "text/plain"
        },
        body: content,
        throw: false
      });
      return response.status === 200;
    } catch (error) {
      console.error("Error updating file in Drive:", error);
      return false;
    }
  }
  setupAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    this.syncIntervalId = window.setInterval(() => {
      this.syncWithGoogleDrive();
    }, this.settings.syncInterval);
  }
  resetGoogleAPIState() {
    console.log("Resetting Google API state...");
    this.isGoogleApiLoaded = false;
    console.log("Google API state reset completed");
  }
  async testDriveAPIConnection() {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      if (!this.settings.accessToken) {
        console.log("No access token available for testing");
        new import_obsidian.Notice("\u274C Please authenticate first");
        return false;
      }
      console.log("Testing Google Drive API connection...");
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/about?fields=user",
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
        // 수동 에러 처리
      });
      console.log("API Response Status:", response.status);
      console.log("API Response Headers:", response.headers);
      if (response.status === 200) {
        const data = response.json;
        console.log("Drive API test successful:", data);
        new import_obsidian.Notice(`\u2705 Drive API connection successful. User: ${((_a = data.user) == null ? void 0 : _a.displayName) || "Unknown"}`);
        return true;
      } else if (response.status === 401) {
        console.error("Authentication failed - Token expired or invalid");
        new import_obsidian.Notice("\u274C Authentication expired. Please sign in again.");
        this.settings.accessToken = "";
        await this.saveSettings();
        new import_obsidian.Notice('Click "1. Open Auth URL" again to re-authenticate.');
        return false;
      } else if (response.status === 403) {
        console.error("API access denied - Check API key and permissions");
        try {
          const errorData = response.json;
          console.error("Error details:", errorData);
          if ((_c = (_b = errorData.error) == null ? void 0 : _b.message) == null ? void 0 : _c.includes("API key")) {
            new import_obsidian.Notice("\u274C Invalid API Key. Please check your API Key in settings.");
          } else if ((_e = (_d = errorData.error) == null ? void 0 : _d.message) == null ? void 0 : _e.includes("quota")) {
            new import_obsidian.Notice("\u274C API quota exceeded. Try again later.");
          } else {
            new import_obsidian.Notice("\u274C API access denied. Check your API Key and Drive API is enabled.");
          }
        } catch (parseError) {
          new import_obsidian.Notice("\u274C API access denied. Check your API Key and Drive API is enabled.");
        }
        return false;
      } else if (response.status === 400) {
        console.error("Bad request - Check API parameters");
        new import_obsidian.Notice("\u274C Bad request. Check your API configuration.");
        return false;
      } else {
        console.error(`Drive API test failed: ${response.status}`);
        try {
          const errorData = response.json;
          console.error("Error details:", errorData);
        } catch (parseError) {
          console.error("Could not parse error response");
        }
        new import_obsidian.Notice(`\u274C Drive API connection failed (Status: ${response.status}). Check console for details.`);
        return false;
      }
    } catch (error) {
      console.error("Drive API test error:", error);
      if ((_f = error.message) == null ? void 0 : _f.includes("Network")) {
        new import_obsidian.Notice("\u274C Network error. Check your internet connection.");
      } else if ((_g = error.message) == null ? void 0 : _g.includes("CORS")) {
        new import_obsidian.Notice("\u274C CORS error. This should not happen with requestUrl.");
      } else {
        new import_obsidian.Notice("\u274C Unexpected error occurred. Check console for details.");
      }
      return false;
    }
  }
};
var GDriveSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Google Drive File Sync Settings" });
    containerEl.createEl("h3", { text: "Google Drive API Configuration" });
    new import_obsidian.Setting(containerEl).setName("Client ID").setDesc("Google Drive API Client ID (Desktop Application type)").addText((text) => text.setPlaceholder("Enter your Client ID").setValue(this.plugin.settings.clientId).onChange(async (value) => {
      this.plugin.settings.clientId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Client Secret").setDesc("Google Drive API Client Secret (from Google Cloud Console)").addText((text) => text.setPlaceholder("Enter your Client Secret").setValue(this.plugin.settings.clientSecret).onChange(async (value) => {
      this.plugin.settings.clientSecret = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Google Drive API Key (from Google Cloud Console)").addText((text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Sync Configuration" });
    new import_obsidian.Setting(containerEl).setName("Sync Folder").setDesc("Local folder to sync with Google Drive").addText((text) => text.setPlaceholder("e.g., Documents/Sync").setValue(this.plugin.settings.syncFolder).onChange(async (value) => {
      this.plugin.settings.syncFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Google Drive Folder").setDesc("Name of the folder to create/use in Google Drive").addText((text) => text.setPlaceholder("e.g., Obsidian-Sync").setValue(this.plugin.settings.driveFolder).onChange(async (value) => {
      this.plugin.settings.driveFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include Subfolders").setDesc("Sync files from subfolders recursively").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeSubfolders).onChange(async (value) => {
      this.plugin.settings.includeSubfolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync at regular intervals").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.setupAutoSync();
      } else if (this.plugin.syncIntervalId) {
        window.clearInterval(this.plugin.syncIntervalId);
        this.plugin.syncIntervalId = null;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("How often to sync (in minutes)").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.syncInterval / 6e4).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.syncInterval = value * 6e4;
      await this.plugin.saveSettings();
      if (this.plugin.settings.autoSync) {
        this.plugin.setupAutoSync();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Mode").setDesc("How to determine if files need to be synced").addDropdown((dropdown) => dropdown.addOption("always", "Always sync (force upload)").addOption("modified", "Modified time comparison (recommended)").addOption("checksum", "Content checksum comparison (most accurate)").setValue(this.plugin.settings.syncMode).onChange(async (value) => {
      this.plugin.settings.syncMode = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Authentication" });
    new import_obsidian.Setting(containerEl).setName("Check Configuration").setDesc("Verify that Client ID, Client Secret, and API Key are properly configured").addButton((button) => button.setButtonText("Check").onClick(() => {
      if (!this.plugin.settings.clientId || !this.plugin.settings.clientSecret || !this.plugin.settings.apiKey) {
        new import_obsidian.Notice("\u274C Please set Client ID, Client Secret, and API Key");
      } else {
        new import_obsidian.Notice("\u2705 Configuration looks good! You can now authenticate.");
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Desktop App Authentication").setDesc("Authenticate with Google Drive using Desktop Application Client ID").addButton((button) => button.setButtonText("1. Open Auth URL").setCta().onClick(async () => {
      if (!this.plugin.settings.clientId || !this.plugin.settings.clientSecret) {
        new import_obsidian.Notice("\u274C Please set Client ID and Client Secret first");
        return;
      }
      await this.plugin.authenticateGoogleDrive();
    }));
    new import_obsidian.Setting(containerEl).setName("Authorization Code").setDesc("Step 2: After authentication, paste the authorization code here").addText((text) => text.setPlaceholder("Paste authorization code here...").setValue("").onChange(async (value) => {
    })).addButton((button) => button.setButtonText("2. Exchange for Token").setCta().onClick(async (evt) => {
      var _a;
      const textInput = containerEl.querySelector('input[placeholder="Paste authorization code here..."]');
      const authCode = (_a = textInput == null ? void 0 : textInput.value) == null ? void 0 : _a.trim();
      if (!authCode) {
        new import_obsidian.Notice("\u274C Please enter authorization code first");
        return;
      }
      console.log("Attempting to exchange authorization code...");
      const success = await this.plugin.exchangeCodeForToken(authCode);
      if (success) {
        if (textInput)
          textInput.value = "";
        setTimeout(async () => {
          await this.plugin.testDriveAPIConnection();
        }, 1e3);
      }
    }));
    containerEl.createEl("h3", { text: "Testing & Debugging" });
    new import_obsidian.Setting(containerEl).setName("Debug Token").setDesc("Show current token status and validity").addButton((button) => button.setButtonText("Debug").onClick(async () => {
      if (!this.plugin.settings.accessToken) {
        new import_obsidian.Notice("\u274C No access token stored");
        return;
      }
      console.log("=== TOKEN DEBUG INFO ===");
      console.log("Token exists:", !!this.plugin.settings.accessToken);
      console.log("Token length:", this.plugin.settings.accessToken.length);
      console.log("Token preview:", this.plugin.settings.accessToken.substring(0, 20) + "...");
      const tokenParts = this.plugin.settings.accessToken.split(".");
      console.log("Token format:", tokenParts.length === 3 ? "JWT" : "Bearer");
      new import_obsidian.Notice(`Token info logged to console. Length: ${this.plugin.settings.accessToken.length}`);
    }));
    new import_obsidian.Setting(containerEl).setName("Manual Token Input").setDesc("Manually enter access token for testing (temporary solution)").addText((text) => text.setPlaceholder("Paste access token here...").setValue("").onChange(async (value) => {
    })).addButton((button) => button.setButtonText("Test Token").onClick(async (evt) => {
      var _a;
      const textInput = containerEl.querySelector('input[placeholder="Paste access token here..."]');
      const tempToken = (_a = textInput == null ? void 0 : textInput.value) == null ? void 0 : _a.trim();
      if (!tempToken) {
        new import_obsidian.Notice("\u274C Please enter a token first");
        return;
      }
      const originalToken = this.plugin.settings.accessToken;
      this.plugin.settings.accessToken = tempToken;
      console.log("Testing with manual token...");
      const testResult = await this.plugin.testDriveAPIConnection();
      if (testResult) {
        new import_obsidian.Notice("\u2705 Manual token works! You can save it.");
        const saveToken = confirm("Token works! Do you want to save it to settings?");
        if (saveToken) {
          await this.plugin.saveSettings();
          new import_obsidian.Notice("Token saved to settings.");
        } else {
          this.plugin.settings.accessToken = originalToken;
        }
      } else {
        this.plugin.settings.accessToken = originalToken;
        new import_obsidian.Notice("\u274C Manual token test failed.");
      }
      if (textInput)
        textInput.value = "";
    }));
    new import_obsidian.Setting(containerEl).setName("Test API Connection").setDesc("Test your current access token with Google Drive API").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      await this.plugin.testDriveAPIConnection();
    }));
    containerEl.createEl("h3", { text: "Sync Actions" });
    new import_obsidian.Setting(containerEl).setName("Preview Sync").setDesc("Show what files would be synced (without actually syncing)").addButton((button) => button.setButtonText("Preview").onClick(async () => {
      if (!this.plugin.settings.syncFolder) {
        new import_obsidian.Notice("\u274C Please set a sync folder first");
        return;
      }
      const folder = this.plugin.app.vault.getAbstractFileByPath(this.plugin.settings.syncFolder);
      if (!folder || !(folder instanceof import_obsidian.TFolder)) {
        new import_obsidian.Notice("\u274C Sync folder not found");
        return;
      }
      const files = await this.plugin.collectFilesToSync(folder, this.plugin.settings.includeSubfolders);
      console.log("=== SYNC PREVIEW ===");
      console.log(`Sync folder: ${this.plugin.settings.syncFolder}`);
      console.log(`Google Drive folder: ${this.plugin.settings.driveFolder}`);
      console.log(`Include subfolders: ${this.plugin.settings.includeSubfolders}`);
      console.log(`Sync mode: ${this.plugin.settings.syncMode}`);
      console.log(`Last sync: ${this.plugin.settings.lastSyncTime ? new Date(this.plugin.settings.lastSyncTime).toLocaleString() : "Never"}`);
      console.log(`Files to sync (${files.length}):`);
      files.forEach((file) => {
        const modTime = new Date(file.stat.mtime).toLocaleString();
        console.log(`  - ${file.path} (modified: ${modTime})`);
      });
      new import_obsidian.Notice(`\u{1F4CB} Found ${files.length} files to sync. Check console for details.`);
    }));
    new import_obsidian.Setting(containerEl).setName("Manual Sync").setDesc("Manually trigger sync with Google Drive").addButton((button) => button.setButtonText("Sync Now").setCta().onClick(async () => {
      await this.plugin.syncWithGoogleDrive();
    }));
    new import_obsidian.Setting(containerEl).setName("Reset API State").setDesc("Reset Google API state if you encounter issues").addButton((button) => button.setButtonText("Reset").setWarning().onClick(() => {
      this.plugin.resetGoogleAPIState();
      new import_obsidian.Notice("Google API state reset. You may need to re-authenticate.");
    }));
    new import_obsidian.Setting(containerEl).setName("Sign Out").setDesc("Revoke Google Drive access and sign out").addButton((button) => button.setButtonText("Sign Out").setWarning().onClick(async () => {
      await this.plugin.revokeGoogleDriveAccess();
    }));
    containerEl.createEl("h3", { text: "Authentication Status" });
    const statusEl = containerEl.createEl("div");
    const updateStatus = () => {
      const isAuth = this.plugin.isAuthenticated();
      statusEl.innerHTML = `
                <div style="padding: 10px; border-radius: 4px; margin-bottom: 10px; ${isAuth ? "background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724;" : "background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24;"}">
                    <strong>Authentication:</strong> ${isAuth ? "\u2705 Authenticated" : "\u274C Not Authenticated"}
                    ${this.plugin.settings.accessToken ? "<br><small>Access token is stored</small>" : "<br><small>No access token stored</small>"}
                </div>
                <div style="padding: 10px; border-radius: 4px; background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460;">
                    <strong>Mode:</strong> \u2705 Desktop Application (Folder Structure Preserved)
                    <br><small>Creates actual folders in Google Drive matching your local structure</small>
                </div>
            `;
    };
    updateStatus();
    const originalSaveSettings = this.plugin.saveSettings.bind(this.plugin);
    this.plugin.saveSettings = async () => {
      await originalSaveSettings();
      updateStatus();
    };
    containerEl.createEl("h3", { text: "Setup Instructions" });
    const instructionsEl = containerEl.createEl("div");
    instructionsEl.innerHTML = `
            <div style="background-color: #d4edda; border: 1px solid #c3e6cb; padding: 10px; margin: 10px 0; border-radius: 4px;">
                <p><strong>\u2705 Google Cloud Console \uC124\uC815 (Desktop Application):</strong></p>
                <ol>
                    <li><a href="https://console.cloud.google.com/apis/credentials" target="_blank">Google Cloud Console - Credentials</a> \uC811\uC18D</li>
                    <li>"Create Credentials" \u2192 "OAuth client ID" \uC120\uD0DD</li>
                    <li><strong>Application type: "Desktop application"</strong> \uC120\uD0DD (\uC911\uC694!)</li>
                    <li>Name \uC785\uB825 \uD6C4 "Create" \uD074\uB9AD</li>
                    <li>\uC0DD\uC131\uB41C <strong>Client ID</strong>\uC640 <strong>Client Secret</strong>\uC744 \uC704 \uC124\uC815\uC5D0 \uC785\uB825</li>
                    <li>Google Drive API\uAC00 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uB294\uC9C0 \uD655\uC778</li>
                </ol>
                <p><strong>\uC7A5\uC810:</strong> Redirect URI \uC124\uC815\uC774 \uD544\uC694 \uC5C6\uC5B4 \uB354 \uAC04\uB2E8\uD569\uB2C8\uB2E4!</p>
                <p><strong>\u26A0\uFE0F \uC911\uC694:</strong> Desktop Application\uC5D0\uC11C\uB294 Client ID\uC640 Client Secret\uC774 \uBAA8\uB450 \uD544\uC694\uD569\uB2C8\uB2E4.</p>
            </div>
            <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 10px; margin: 10px 0; border-radius: 4px;">
                <p><strong>\u{1F504} Desktop App \uC778\uC99D \uBC29\uBC95:</strong></p>
                <ol>
                    <li><strong>"1. Open Auth URL" \uD074\uB9AD</strong> \u2192 \uBE0C\uB77C\uC6B0\uC800\uC5D0\uC11C Google \uC778\uC99D \uD398\uC774\uC9C0 \uC5F4\uB9BC</li>
                    <li><strong>Google \uACC4\uC815\uC73C\uB85C \uB85C\uADF8\uC778</strong> \u2192 Drive API \uAD8C\uD55C \uD5C8\uC6A9</li>
                    <li><strong>Authorization Code \uBCF5\uC0AC</strong> \u2192 \uBE0C\uB77C\uC6B0\uC800\uC5D0 \uD45C\uC2DC\uB418\uB294 \uCF54\uB4DC \uBCF5\uC0AC</li>
                    <li><strong>\uCF54\uB4DC \uBD99\uC5EC\uB123\uAE30</strong> \u2192 "Authorization Code" \uC785\uB825\uB780\uC5D0 \uBD99\uC5EC\uB123\uAE30</li>
                    <li><strong>"2. Exchange for Token" \uD074\uB9AD</strong> \u2192 \uD1A0\uD070\uC73C\uB85C \uAD50\uD658 \uBC0F \uC790\uB3D9 \uD14C\uC2A4\uD2B8</li>
                </ol>
            </div>
            <div style="background-color: #e7f3ff; border: 1px solid #b3d7ff; padding: 10px; margin: 10px 0; border-radius: 4px;">
                <p><strong>\u{1F4C1} \uB3D9\uAE30\uD654 \uB3D9\uC791 \uBC29\uC2DD:</strong></p>
                <ul>
                    <li><strong>\uD558\uC704 \uD3F4\uB354:</strong> "Include Subfolders" \uC124\uC815\uC5D0 \uB530\uB77C \uC7AC\uADC0\uC801\uC73C\uB85C \uCC98\uB9AC\uB429\uB2C8\uB2E4</li>
                    <li><strong>\uD3F4\uB354 \uAD6C\uC870:</strong> Google Drive\uC5D0 \uC6D0\uBCF8\uACFC \uB3D9\uC77C\uD55C \uC2E4\uC81C \uD3F4\uB354 \uAD6C\uC870\uB97C \uC0DD\uC131\uD569\uB2C8\uB2E4
                        <br>\uC608: <code>62.\uAC1C\uC778\uC9C0\uC2DD/10.\uCD5C\uADFC\uC2DD/\uC138\uBBF8\uB098/Team.md</code> \u2192 Google Drive\uC5D0\uC11C\uB3C4 \uAC19\uC740 \uAD6C\uC870
                    </li>
                    <li><strong>\uD30C\uC77C \uD0C0\uC785:</strong> .md, .txt, .json, .csv, .html, .css, .js \uD30C\uC77C\uB9CC \uB3D9\uAE30\uD654</li>
                    <li><strong>\uC81C\uC678 \uD30C\uC77C:</strong> \uC228\uAE40 \uD30C\uC77C(.), \uC784\uC2DC \uD30C\uC77C(.tmp), \uBC31\uC5C5 \uD30C\uC77C(.bak) \uC81C\uC678</li>
                    <li><strong>Google Drive \uC704\uCE58:</strong> \uC9C0\uC815\uD55C "Google Drive Folder" \uC774\uB984\uC73C\uB85C \uB8E8\uD2B8\uC5D0 \uC0DD\uC131</li>
                </ul>
                <p><strong>\u{1F504} \uB3D9\uAE30\uD654 \uBAA8\uB4DC:</strong></p>
                <ul>
                    <li><strong>Always sync:</strong> \uBAA8\uB4E0 \uD30C\uC77C\uC744 \uD56D\uC0C1 \uC5C5\uB85C\uB4DC (\uAC00\uC7A5 \uC548\uC804\uD558\uC9C0\uB9CC \uB290\uB9BC)</li>
                    <li><strong>Modified time:</strong> \uB85C\uCEEC \uD30C\uC77C\uC774 \uB354 \uCD5C\uADFC\uC5D0 \uC218\uC815\uB41C \uACBD\uC6B0\uB9CC \uB3D9\uAE30\uD654 (\uAD8C\uC7A5)</li>
                    <li><strong>Content checksum:</strong> \uD30C\uC77C \uB0B4\uC6A9 \uD574\uC2DC\uB97C \uBE44\uAD50\uD558\uC5EC \uC2E4\uC81C \uBCC0\uACBD\uB41C \uACBD\uC6B0\uB9CC \uB3D9\uAE30\uD654 (\uAC00\uC7A5 \uC815\uD655\uD558\uC9C0\uB9CC \uB290\uB9BC)</li>
                </ul>
                <p><strong>\u{1F4A1} \uD301:</strong> "Preview Sync" \uBC84\uD2BC\uC73C\uB85C \uB3D9\uAE30\uD654 \uB300\uC0C1 \uD30C\uC77C\uC744 \uBBF8\uB9AC \uD655\uC778\uD558\uC138\uC694!</p>
            </div>
            <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; margin: 10px 0; border-radius: 4px;">
                <p><strong>\u{1F527} \uB300\uC548 \uBC29\uBC95 (OAuth Playground):</strong></p>
                <ol>
                    <li><strong>Google OAuth Playground \uC0AC\uC6A9:</strong>
                        <br>\u2022 <a href="https://developers.google.com/oauthplayground/" target="_blank">OAuth 2.0 Playground</a> \uC811\uC18D
                        <br>\u2022 Step 1: "Drive API v3" \u2192 "https://www.googleapis.com/auth/drive.file" \uC120\uD0DD
                        <br>\u2022 "Authorize APIs" \uD074\uB9AD\uD558\uC5EC \uC778\uC99D
                        <br>\u2022 Step 2: "Exchange authorization code for tokens" \uD074\uB9AD
                        <br>\u2022 "Access token" \uBCF5\uC0AC\uD558\uC5EC \uC704\uC758 "Manual Token Input"\uC5D0 \uBD99\uC5EC\uB123\uAE30
                    </li>
                    <li><strong>\uD1A0\uD070 \uB9CC\uB8CC \uC2DC\uAC04:</strong> \uBCF4\uD1B5 1\uC2DC\uAC04 \uD6C4 \uB9CC\uB8CC\uB428</li>
                    <li><strong>\uAD8C\uD55C \uD655\uC778:</strong> Google Drive API \uD65C\uC131\uD654 \uBC0F \uC62C\uBC14\uB978 scope \uC124\uC815</li>
                </ol>
            </div>
        `;
  }
};
