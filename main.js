/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GDriveSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  clientId: "",
  clientSecret: "",
  apiKey: "",
  syncFolders: [],
  syncWholeVault: false,
  autoSync: false,
  syncInterval: 3e5,
  accessToken: "",
  driveFolder: "Obsidian-Sync",
  includeSubfolders: true,
  syncMode: "modified",
  lastSyncTime: 0,
  syncDirection: "bidirectional",
  conflictResolution: "newer",
  createMissingFolders: true,
  selectedDriveFolders: []
};
var SyncProgressModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
    this.isCompleted = false;
    this.isCancelled = false;
    this.logs = [];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const header = contentEl.createEl("div", {
      attr: { style: "display: flex; align-items: center; margin-bottom: 20px;" }
    });
    header.createEl("h2", {
      text: "Google Drive Sync Progress",
      attr: { style: "margin: 0; flex-grow: 1;" }
    });
    const progressSection = contentEl.createEl("div", {
      attr: { style: "margin-bottom: 20px;" }
    });
    const progressContainer = progressSection.createEl("div", {
      attr: {
        style: "background-color: var(--background-modifier-border); border-radius: 10px; height: 20px; margin-bottom: 10px; overflow: hidden;"
      }
    });
    this.progressBar = progressContainer.createEl("div", {
      attr: {
        style: "background: linear-gradient(90deg, #4CAF50, #45a049); height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px;"
      }
    });
    this.progressEl = progressSection.createEl("div", {
      text: "0%",
      attr: { style: "text-align: center; font-weight: bold; color: var(--text-accent);" }
    });
    this.statusEl = contentEl.createEl("div", {
      text: "Initializing sync...",
      attr: {
        style: "margin: 15px 0; padding: 10px; background-color: var(--background-secondary); border-radius: 5px; font-weight: bold;"
      }
    });
    const logSection = contentEl.createEl("div", {
      attr: { style: "margin: 20px 0;" }
    });
    logSection.createEl("h4", {
      text: "Sync Log:",
      attr: { style: "margin-bottom: 10px;" }
    });
    this.logEl = logSection.createEl("div", {
      attr: {
        style: "max-height: 200px; overflow-y: auto; background-color: var(--background-primary-alt); border: 1px solid var(--background-modifier-border); border-radius: 5px; padding: 10px; font-family: monospace; font-size: 12px; line-height: 1.4;"
      }
    });
    const buttonContainer = contentEl.createEl("div", {
      attr: { style: "text-align: right; margin-top: 20px; border-top: 1px solid var(--background-modifier-border); padding-top: 15px;" }
    });
    this.cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-warning",
      attr: { style: "margin-right: 10px;" }
    });
    this.closeButton = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    this.closeButton.style.display = "none";
    this.cancelButton.onclick = () => {
      if (!this.isCompleted) {
        this.isCancelled = true;
        this.updateStatus("\u{1F6D1} Cancelling sync...", "warning");
        this.cancelButton.disabled = true;
      }
    };
    this.closeButton.onclick = () => this.close();
  }
  updateProgress(current, total, operation = "") {
    if (this.isCancelled)
      return;
    const percentage = total > 0 ? Math.round(current / total * 100) : 0;
    this.progressBar.style.width = `${percentage}%`;
    this.progressEl.textContent = `${percentage}% (${current}/${total})`;
    if (operation) {
      this.updateStatus(`\u{1F504} ${operation}`, "info");
    }
  }
  updateStatus(message, type = "info") {
    if (this.isCancelled && type !== "warning")
      return;
    const icons = {
      info: "\u{1F4AC}",
      success: "\u2705",
      warning: "\u26A0\uFE0F",
      error: "\u274C"
    };
    const colors = {
      info: "var(--text-normal)",
      success: "#4CAF50",
      warning: "#FF9800",
      error: "#F44336"
    };
    this.statusEl.textContent = `${icons[type]} ${message}`;
    this.statusEl.style.color = colors[type];
  }
  addLog(message) {
    if (this.isCancelled)
      return;
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${message}`;
    this.logs.push(logEntry);
    const logLine = this.logEl.createEl("div", {
      text: logEntry,
      attr: { style: "margin-bottom: 2px;" }
    });
    this.logEl.scrollTop = this.logEl.scrollHeight;
  }
  markCompleted(result) {
    this.isCompleted = true;
    this.progressBar.style.width = "100%";
    this.progressEl.textContent = "100% - Completed";
    const hasErrors = result.errors > 0;
    const resultIcon = hasErrors ? "\u26A0\uFE0F" : "\u2705";
    const resultColor = hasErrors ? "#FF9800" : "#4CAF50";
    const summary = [
      `${result.uploaded} uploaded`,
      `${result.downloaded} downloaded`,
      `${result.skipped} skipped`,
      result.conflicts > 0 ? `${result.conflicts} conflicts` : "",
      result.errors > 0 ? `${result.errors} errors` : ""
    ].filter(Boolean).join(", ");
    this.updateStatus(`${resultIcon} Sync completed: ${summary}`, hasErrors ? "warning" : "success");
    this.addLog("=== SYNC COMPLETED ===");
    this.addLog(`\u{1F4E4} Uploaded: ${result.uploaded} files`);
    this.addLog(`\u{1F4E5} Downloaded: ${result.downloaded} files`);
    this.addLog(`\u23ED\uFE0F Skipped: ${result.skipped} files`);
    if (result.conflicts > 0)
      this.addLog(`\u26A1 Conflicts resolved: ${result.conflicts}`);
    if (result.errors > 0)
      this.addLog(`\u274C Errors: ${result.errors}`);
    if (result.createdFolders.length > 0) {
      this.addLog(`\u{1F4C1} Created folders: ${result.createdFolders.length}`);
      result.createdFolders.forEach((folder) => this.addLog(`  - ${folder}`));
    }
    this.cancelButton.style.display = "none";
    this.closeButton.style.display = "inline-block";
  }
  markCancelled() {
    this.isCancelled = true;
    this.updateStatus("\u{1F6D1} Sync cancelled by user", "warning");
    this.addLog("Sync operation cancelled by user");
    this.cancelButton.style.display = "none";
    this.closeButton.style.display = "inline-block";
    this.closeButton.textContent = "Close";
  }
  shouldCancel() {
    return this.isCancelled;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CreateFolderModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Create New Google Drive Folder" });
    const form = contentEl.createEl("div", {
      attr: { style: "margin: 20px 0;" }
    });
    const inputLabel = form.createEl("label", {
      text: "Folder Name:",
      attr: { style: "display: block; margin-bottom: 8px; font-weight: bold;" }
    });
    const folderInput = form.createEl("input", {
      type: "text",
      placeholder: "Enter folder name...",
      attr: {
        style: "width: 100%; padding: 8px; border: 1px solid var(--background-modifier-border); border-radius: 4px; margin-bottom: 15px;"
      }
    });
    folderInput.focus();
    const buttonContainer = contentEl.createEl("div", {
      attr: { style: "text-align: right; margin-top: 20px; border-top: 1px solid var(--background-modifier-border); padding-top: 15px;" }
    });
    const createButton = buttonContainer.createEl("button", {
      text: "Create Folder",
      cls: "mod-cta",
      attr: { style: "margin-right: 10px;" }
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    const handleSubmit = () => {
      const folderName = folderInput.value.trim();
      if (!folderName) {
        new import_obsidian.Notice("\u274C Please enter a folder name");
        folderInput.focus();
        return;
      }
      if (!/^[^<>:"/\\|?*]+$/.test(folderName)) {
        new import_obsidian.Notice('\u274C Invalid folder name. Please avoid special characters: < > : " / \\ | ? *');
        folderInput.focus();
        return;
      }
      this.onSubmit(folderName);
      this.close();
    };
    createButton.onclick = handleSubmit;
    cancelButton.onclick = () => this.close();
    folderInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleSubmit();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.close();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DriveFolderModal = class extends import_obsidian.Modal {
  constructor(app, plugin, onChoose) {
    super(app);
    this.folders = [];
    this.expandedFolders = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.onChoose = onChoose;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Google Drive Folder" });
    const loadingEl = contentEl.createEl("div", { text: "Loading Google Drive folders..." });
    try {
      await this.loadDriveFolders();
      loadingEl.remove();
      this.renderFolderTree(contentEl);
    } catch (error) {
      loadingEl.textContent = "Failed to load folders. Please check your authentication.";
      console.error("Error loading Drive folders:", error);
    }
    const buttonContainer = contentEl.createEl("div", {
      attr: { style: "text-align: right; margin-top: 15px; border-top: 1px solid var(--background-modifier-border); padding-top: 15px;" }
    });
    const createFolderButton = buttonContainer.createEl("button", {
      text: "Create New Folder",
      cls: "mod-cta",
      attr: { style: "margin-right: 10px;" }
    });
    createFolderButton.onclick = () => this.showCreateFolderDialog();
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.onclick = () => this.close();
  }
  async loadDriveFolders() {
    try {
      const rootFolder = await this.plugin.getOrCreateDriveFolder();
      if (!rootFolder) {
        throw new Error("Failed to access root folder");
      }
      this.folders = await this.getAllDriveFoldersRecursive(rootFolder.id, "");
      console.log("Loaded folders:", this.folders);
    } catch (error) {
      console.error("Error loading Drive folders:", error);
      throw error;
    }
  }
  async getAllDriveFoldersRecursive(folderId, basePath) {
    const folders = [];
    try {
      const query = `'${folderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`;
      const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,parents)&pageSize=1000`;
      const response = await (0, import_obsidian.requestUrl)({
        url,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.plugin.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        for (const folder of data.files || []) {
          const folderPath = basePath ? `${basePath}/${folder.name}` : folder.name;
          const driveFolder = {
            id: folder.id,
            name: folder.name,
            path: folderPath,
            mimeType: folder.mimeType,
            parents: folder.parents
          };
          folders.push(driveFolder);
        }
      }
    } catch (error) {
      console.error("Error loading folders:", error);
    }
    return folders;
  }
  async deleteDriveFolder(folderId, folderName) {
    try {
      console.log(`Attempting to delete folder: ${folderName} (${folderId})`);
      const confirmDelete = confirm(`Are you sure you want to delete the folder "${folderName}" from Google Drive?

This action cannot be undone and will move the folder to trash.`);
      if (!confirmDelete) {
        console.log("Folder deletion cancelled by user");
        return false;
      }
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files/${folderId}`,
        method: "DELETE",
        headers: {
          "Authorization": `Bearer ${this.plugin.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 204 || response.status === 200) {
        console.log(`\u2713 Successfully deleted folder: ${folderName}`);
        new import_obsidian.Notice(`\u2705 Folder "${folderName}" moved to trash`);
        return true;
      } else {
        console.error("Failed to delete folder:", response.status, response.json);
        new import_obsidian.Notice(`\u274C Failed to delete folder "${folderName}"`);
        return false;
      }
    } catch (error) {
      console.error("Error deleting folder:", error);
      new import_obsidian.Notice(`\u274C Error deleting folder "${folderName}"`);
      return false;
    }
  }
  renderFolderTree(container) {
    const treeContainer = container.createEl("div", {
      cls: "drive-folder-tree-container",
      attr: {
        style: "max-height: 400px; overflow-y: auto; border: 1px solid var(--background-modifier-border); border-radius: 4px; padding: 10px; margin: 10px 0;"
      }
    });
    const sortedFolders = this.folders.sort((a, b) => a.name.localeCompare(b.name));
    if (sortedFolders.length === 0) {
      treeContainer.createEl("p", {
        text: "No folders found in Google Drive root folder.",
        attr: { style: "text-align: center; color: var(--text-muted); margin: 20px 0;" }
      });
      return;
    }
    sortedFolders.forEach((folder) => {
      this.renderFolderNode(treeContainer, folder, 0);
    });
  }
  renderFolderNode(container, folder, depth) {
    const nodeEl = container.createEl("div", {
      cls: "drive-folder-tree-node",
      attr: {
        style: `margin-left: ${depth * 20}px; cursor: pointer; padding: 4px 8px; border-radius: 4px; margin-bottom: 2px;`
      }
    });
    nodeEl.addEventListener("mouseenter", () => {
      nodeEl.style.backgroundColor = "var(--background-modifier-hover)";
    });
    nodeEl.addEventListener("mouseleave", () => {
      nodeEl.style.backgroundColor = "transparent";
    });
    const hasChildren = false;
    const isExpanded = false;
    const folderContent = nodeEl.createEl("div", {
      attr: { style: "display: flex; align-items: center;" }
    });
    const folderIcon = folderContent.createEl("span", {
      text: "\u{1F4C1}",
      attr: { style: "margin-right: 8px;" }
    });
    const folderName = folderContent.createEl("span", {
      text: folder.name,
      cls: "folder-name",
      attr: { style: "flex-grow: 1; cursor: pointer;" }
    });
    const folderPath = folderContent.createEl("small", {
      text: `(${folder.path || "root"})`,
      attr: { style: "margin-left: 10px; color: var(--text-muted); font-size: 0.8em;" }
    });
    const buttonContainer = folderContent.createEl("div", {
      attr: { style: "margin-left: 10px; display: flex; gap: 5px;" }
    });
    const selectBtn = buttonContainer.createEl("button", {
      text: "Select",
      cls: "mod-small mod-cta",
      attr: {
        style: "padding: 2px 8px; font-size: 11px;"
      }
    });
    const deleteBtn = buttonContainer.createEl("button", {
      text: "Delete",
      cls: "mod-small mod-warning",
      attr: {
        style: "padding: 2px 8px; font-size: 11px;"
      }
    });
    selectBtn.onclick = (e) => {
      e.stopPropagation();
      this.onChoose(folder);
      this.close();
    };
    deleteBtn.onclick = async (e) => {
      e.stopPropagation();
      const success = await this.deleteDriveFolder(folder.id, folder.name);
      if (success) {
        await this.loadDriveFolders();
        this.refreshTree();
      }
    };
  }
  refreshTree() {
    const { contentEl } = this;
    const existingContainer = contentEl.querySelector(".drive-folder-tree-container");
    if (existingContainer) {
      existingContainer.remove();
    }
    this.renderFolderTree(contentEl);
  }
  async showCreateFolderDialog() {
    const createModal = new CreateFolderModal(this.app, async (folderName) => {
      try {
        const rootFolder = await this.plugin.getOrCreateDriveFolder();
        if (!rootFolder) {
          new import_obsidian.Notice("\u274C Failed to access root folder");
          return;
        }
        const newFolder = await this.createDriveFolder(folderName, rootFolder.id);
        if (newFolder) {
          new import_obsidian.Notice(`\u2705 Created folder: ${folderName}`);
          await this.loadDriveFolders();
          this.onOpen();
        }
      } catch (error) {
        console.error("Error creating folder:", error);
        new import_obsidian.Notice("\u274C Failed to create folder");
      }
    });
    createModal.open();
  }
  async createDriveFolder(name, parentId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/files",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.plugin.settings.accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name,
          mimeType: "application/vnd.google-apps.folder",
          parents: [parentId]
        }),
        throw: false
      });
      if (response.status === 200 || response.status === 201) {
        const folderData = response.json;
        return {
          id: folderData.id,
          name: folderData.name,
          path: folderData.name,
          mimeType: folderData.mimeType,
          parents: folderData.parents
        };
      }
    } catch (error) {
      console.error("Error creating Drive folder:", error);
    }
    return null;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var GDriveSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    this.isGoogleApiLoaded = false;
  }
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon("cloud", "Google Drive Sync", (evt) => {
      this.syncWithGoogleDrive(false);
    });
    ribbonIconEl.addClass("gdrive-sync-ribbon-class");
    this.addCommand({
      id: "sync-with-gdrive",
      name: "Sync with Google Drive",
      callback: () => {
        this.syncWithGoogleDrive(false);
      }
    });
    this.addCommand({
      id: "download-from-gdrive",
      name: "Download from Google Drive",
      callback: () => {
        this.downloadFromGoogleDrive(false);
      }
    });
    this.addCommand({
      id: "upload-to-gdrive",
      name: "Upload to Google Drive",
      callback: () => {
        this.uploadToGoogleDrive(false);
      }
    });
    this.addSettingTab(new GDriveSyncSettingTab(this.app, this));
    console.log("Plugin loaded - Google Drive folder-based sync");
    if (this.settings.autoSync) {
      this.setupAutoSync();
    }
  }
  onunload() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const oldData = await this.loadData();
    if (oldData && oldData.syncFolder && !oldData.syncFolders) {
      this.settings.syncFolders = [oldData.syncFolder];
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // 인증 관련 메서드들
  async authenticateGoogleDrive() {
    console.log("=== Starting Google Drive Desktop Authentication ===");
    if (!this.settings.clientId || !this.settings.clientSecret || !this.settings.apiKey) {
      console.error("Missing credentials");
      new import_obsidian.Notice("\u274C Please set Client ID, Client Secret, and API Key in settings first.");
      return false;
    }
    console.log("\u2713 Credentials are set");
    const authUrl = this.generateAuthUrl();
    new import_obsidian.Notice("Opening browser for Desktop App authentication...");
    console.log("Desktop Auth URL:", authUrl);
    try {
      window.open(authUrl, "_blank");
      new import_obsidian.Notice('\u{1F517} Complete authentication in browser, then copy the authorization code and use "Authorization Code" input in settings.');
      return false;
    } catch (error) {
      console.error("Failed to open browser:", error);
      try {
        navigator.clipboard.writeText(authUrl);
        new import_obsidian.Notice("\u{1F4CB} Auth URL copied to clipboard. Open it in your browser.");
      } catch (clipboardError) {
        console.error("Failed to copy to clipboard:", clipboardError);
        new import_obsidian.Notice("\u274C Failed to open browser. Please check console for auth URL.");
      }
      return false;
    }
  }
  generateAuthUrl() {
    const params = new URLSearchParams({
      client_id: this.settings.clientId,
      redirect_uri: "urn:ietf:wg:oauth:2.0:oob",
      scope: "https://www.googleapis.com/auth/drive.file",
      response_type: "code",
      access_type: "offline",
      prompt: "consent"
    });
    return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
  }
  async exchangeCodeForToken(authCode) {
    try {
      console.log("Exchanging authorization code for access token...");
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://oauth2.googleapis.com/token",
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          client_id: this.settings.clientId,
          client_secret: this.settings.clientSecret,
          code: authCode,
          grant_type: "authorization_code",
          redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
        }).toString(),
        throw: false
      });
      if (response.status === 200) {
        const tokenData = response.json;
        console.log("Token exchange successful");
        this.settings.accessToken = tokenData.access_token;
        await this.saveSettings();
        new import_obsidian.Notice("\u2705 Desktop App authentication successful!");
        return true;
      } else {
        console.error("Token exchange failed:", response.status, response.json);
        new import_obsidian.Notice("\u274C Failed to exchange authorization code for token.");
        return false;
      }
    } catch (error) {
      console.error("Token exchange error:", error);
      new import_obsidian.Notice("\u274C Token exchange failed. Check console for details.");
      return false;
    }
  }
  async revokeGoogleDriveAccess() {
    try {
      console.log("Revoking Google Drive access...");
      if (!this.settings.accessToken) {
        console.log("No access token to revoke");
        new import_obsidian.Notice("No active session to revoke");
        return true;
      }
      this.settings.accessToken = "";
      await this.saveSettings();
      console.log("\u2713 Google Drive access revoked successfully");
      new import_obsidian.Notice("Google Drive access revoked successfully");
      return true;
    } catch (error) {
      console.error("Failed to revoke access:", error);
      new import_obsidian.Notice("Failed to revoke access. Token cleared locally.");
      this.settings.accessToken = "";
      await this.saveSettings();
      return false;
    }
  }
  isAuthenticated() {
    return !!this.settings.accessToken;
  }
  // 메인 동기화 메서드
  async syncWithGoogleDrive(showProgress = false) {
    if (!this.settings.clientId || !this.settings.clientSecret || !this.settings.apiKey) {
      new import_obsidian.Notice("Please configure Google Drive API credentials in settings");
      return this.createEmptyResult();
    }
    if (!this.settings.syncWholeVault && this.settings.selectedDriveFolders.length === 0) {
      new import_obsidian.Notice('Please select Google Drive folders to sync or enable "Sync Whole Vault" in settings');
      return this.createEmptyResult();
    }
    if (!showProgress) {
      new import_obsidian.Notice("Starting Google Drive sync...");
    }
    try {
      if (!this.isAuthenticated()) {
        const message = "Please authenticate first using the Desktop App method.";
        new import_obsidian.Notice(`\u274C ${message}`);
        return this.createEmptyResult();
      }
      let result;
      if (this.settings.syncDirection === "upload") {
        result = await this.uploadToGoogleDrive(showProgress);
      } else if (this.settings.syncDirection === "download") {
        result = await this.downloadFromGoogleDrive(showProgress);
      } else {
        result = await this.bidirectionalSync(showProgress);
      }
      return result;
    } catch (error) {
      console.error("Sync failed:", error);
      new import_obsidian.Notice("\u274C Google Drive sync failed");
      return this.createEmptyResult();
    }
  }
  // 업로드 전용 메서드
  async uploadToGoogleDrive(showProgress = false) {
    console.log("Starting upload to Google Drive...");
    const result = this.createEmptyResult();
    let progressModal = void 0;
    if (showProgress) {
      progressModal = new SyncProgressModal(this.app);
      progressModal.open();
      progressModal.addLog("\u{1F50D} Collecting files to upload...");
      progressModal.updateStatus("Preparing upload...", "info");
    }
    try {
      let allFiles = [];
      let folderTargets = [];
      if (this.settings.syncWholeVault) {
        progressModal == null ? void 0 : progressModal.addLog("\u{1F4C1} Sync mode: Whole Vault");
        const rootFolder = await this.getOrCreateDriveFolder();
        if (!rootFolder) {
          throw new Error("Failed to create or find Google Drive folder");
        }
        allFiles = this.app.vault.getFiles().filter((file) => this.shouldSyncFileType(file));
        folderTargets.push({
          files: allFiles,
          folderId: rootFolder.id,
          name: rootFolder.name
        });
      } else {
        progressModal == null ? void 0 : progressModal.addLog("\u{1F4C2} Sync mode: Selected Folders");
        for (const driveFolder of this.settings.selectedDriveFolders) {
          const localFiles = await this.getLocalFilesForDriveFolder(driveFolder);
          folderTargets.push({
            files: localFiles,
            folderId: driveFolder.id,
            name: driveFolder.name
          });
          allFiles.push(...localFiles);
        }
      }
      progressModal == null ? void 0 : progressModal.addLog(`\u{1F4CB} Found ${allFiles.length} files to process`);
      progressModal == null ? void 0 : progressModal.updateProgress(0, allFiles.length);
      let processedFiles = 0;
      for (const target of folderTargets) {
        if (progressModal == null ? void 0 : progressModal.shouldCancel()) {
          progressModal.markCancelled();
          return result;
        }
        progressModal == null ? void 0 : progressModal.addLog(`\u{1F4E4} Processing folder: ${target.name} (${target.files.length} files)`);
        for (const file of target.files) {
          if (progressModal == null ? void 0 : progressModal.shouldCancel()) {
            progressModal.markCancelled();
            return result;
          }
          try {
            progressModal == null ? void 0 : progressModal.updateProgress(processedFiles, allFiles.length, `Uploading: ${file.name}`);
            progressModal == null ? void 0 : progressModal.addLog(`\u{1F4E4} ${file.path}`);
            const syncResult = await this.syncFileToGoogleDrive(file, target.folderId);
            if (syncResult === "skipped") {
              result.skipped++;
              progressModal == null ? void 0 : progressModal.addLog(`\u23ED\uFE0F Skipped: ${file.name} (no changes)`);
            } else if (syncResult === true) {
              result.uploaded++;
              progressModal == null ? void 0 : progressModal.addLog(`\u2705 Uploaded: ${file.name}`);
            } else {
              result.errors++;
              progressModal == null ? void 0 : progressModal.addLog(`\u274C Failed: ${file.name}`);
            }
          } catch (error) {
            result.errors++;
            progressModal == null ? void 0 : progressModal.addLog(`\u274C Error uploading ${file.name}: ${error.message || "Unknown error"}`);
          }
          processedFiles++;
          await new Promise((resolve) => setTimeout(resolve, 10));
        }
      }
      this.settings.lastSyncTime = Date.now();
      await this.saveSettings();
      progressModal == null ? void 0 : progressModal.addLog("\u{1F389} Upload completed successfully!");
      if (!showProgress) {
        this.reportSyncResult(result);
      } else if (progressModal) {
        progressModal.markCompleted(result);
      }
    } catch (error) {
      console.error("Upload error:", error);
      const errorMessage = `Upload error: ${error.message || "Unknown error"}`;
      if (progressModal) {
        progressModal.addLog(`\u274C ${errorMessage}`);
        progressModal.updateStatus("Upload failed", "error");
        setTimeout(() => progressModal == null ? void 0 : progressModal.markCancelled(), 2e3);
      } else {
        new import_obsidian.Notice(`\u274C ${errorMessage}`);
      }
      result.errors++;
    }
    return result;
  }
  // 다운로드 전용 메서드
  async downloadFromGoogleDrive(showProgress = false) {
    console.log("Starting download from Google Drive...");
    const result = this.createEmptyResult();
    let progressModal = void 0;
    if (showProgress) {
      progressModal = new SyncProgressModal(this.app);
      progressModal.open();
      progressModal.addLog("\u{1F50D} Collecting files to download...");
      progressModal.updateStatus("Preparing download...", "info");
    }
    try {
      let allDriveFiles = [];
      if (this.settings.syncWholeVault) {
        progressModal == null ? void 0 : progressModal.addLog("\u{1F4C1} Download mode: Whole Vault");
        const rootFolder = await this.getOrCreateDriveFolder();
        if (!rootFolder) {
          throw new Error("Failed to find Google Drive folder");
        }
        allDriveFiles = await this.getAllFilesFromDrive(rootFolder.id);
      } else {
        progressModal == null ? void 0 : progressModal.addLog("\u{1F4C2} Download mode: Selected Folders");
        for (const driveFolder of this.settings.selectedDriveFolders) {
          const driveFiles = await this.getAllFilesFromDrive(driveFolder.id, driveFolder.path);
          allDriveFiles.push(...driveFiles);
        }
      }
      progressModal == null ? void 0 : progressModal.addLog(`\u{1F4CB} Found ${allDriveFiles.length} files to download`);
      progressModal == null ? void 0 : progressModal.updateProgress(0, allDriveFiles.length);
      for (let i = 0; i < allDriveFiles.length; i++) {
        if (progressModal == null ? void 0 : progressModal.shouldCancel()) {
          progressModal.markCancelled();
          return result;
        }
        const driveFile = allDriveFiles[i];
        try {
          progressModal == null ? void 0 : progressModal.updateProgress(i, allDriveFiles.length, `Downloading: ${driveFile.name}`);
          progressModal == null ? void 0 : progressModal.addLog(`\u{1F4E5} ${driveFile.path}`);
          await this.downloadFileFromDrive(driveFile, result);
          progressModal == null ? void 0 : progressModal.addLog(`\u2705 Downloaded: ${driveFile.name}`);
        } catch (error) {
          result.errors++;
          progressModal == null ? void 0 : progressModal.addLog(`\u274C Error downloading ${driveFile.name}: ${error.message || "Unknown error"}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 10));
      }
      this.settings.lastSyncTime = Date.now();
      await this.saveSettings();
      progressModal == null ? void 0 : progressModal.addLog("\u{1F389} Download completed successfully!");
      if (!showProgress) {
        this.reportSyncResult(result);
      } else if (progressModal) {
        progressModal.markCompleted(result);
      }
    } catch (error) {
      console.error("Download error:", error);
      const errorMessage = `Download error: ${error.message || "Unknown error"}`;
      if (progressModal) {
        progressModal.addLog(`\u274C ${errorMessage}`);
        progressModal.updateStatus("Download failed", "error");
        setTimeout(() => progressModal == null ? void 0 : progressModal.markCancelled(), 2e3);
      } else {
        new import_obsidian.Notice(`\u274C ${errorMessage}`);
      }
      result.errors++;
    }
    return result;
  }
  // 양방향 동기화 메서드
  async bidirectionalSync(showProgress = false) {
    console.log("Starting bidirectional sync...");
    const result = this.createEmptyResult();
    let progressModal = void 0;
    if (showProgress) {
      progressModal = new SyncProgressModal(this.app);
      progressModal.open();
      progressModal.addLog("\u{1F50D} Analyzing local and remote files...");
      progressModal.updateStatus("Preparing bidirectional sync...", "info");
    }
    try {
      if (this.settings.syncWholeVault) {
        progressModal == null ? void 0 : progressModal.addLog("\u{1F4C1} Bidirectional mode: Whole Vault");
        const rootFolder = await this.getOrCreateDriveFolder();
        if (!rootFolder) {
          throw new Error("Failed to create or find Google Drive folder");
        }
        const localFiles = this.app.vault.getFiles().filter((file) => this.shouldSyncFileType(file));
        const driveFiles = await this.getAllFilesFromDrive(rootFolder.id);
        progressModal == null ? void 0 : progressModal.addLog(`\u{1F4F1} Local files: ${localFiles.length}`);
        progressModal == null ? void 0 : progressModal.addLog(`\u2601\uFE0F Remote files: ${driveFiles.length}`);
        await this.performBidirectionalSync(localFiles, driveFiles, rootFolder.id, result, "", progressModal);
      } else {
        progressModal == null ? void 0 : progressModal.addLog("\u{1F4C2} Bidirectional mode: Selected Folders");
        for (const driveFolder of this.settings.selectedDriveFolders) {
          if (progressModal == null ? void 0 : progressModal.shouldCancel()) {
            progressModal.markCancelled();
            return result;
          }
          progressModal == null ? void 0 : progressModal.addLog(`\u{1F4C1} Processing folder: ${driveFolder.name}`);
          const localFiles = await this.getLocalFilesForDriveFolder(driveFolder);
          const driveFiles = await this.getAllFilesFromDrive(driveFolder.id, driveFolder.path);
          progressModal == null ? void 0 : progressModal.addLog(`  \u{1F4F1} Local files: ${localFiles.length}`);
          progressModal == null ? void 0 : progressModal.addLog(`  \u2601\uFE0F Remote files: ${driveFiles.length}`);
          await this.performBidirectionalSync(localFiles, driveFiles, driveFolder.id, result, driveFolder.path, progressModal);
        }
      }
      this.settings.lastSyncTime = Date.now();
      await this.saveSettings();
      progressModal == null ? void 0 : progressModal.addLog("\u{1F389} Bidirectional sync completed successfully!");
      if (!showProgress) {
        this.reportSyncResult(result);
      } else if (progressModal) {
        progressModal.markCompleted(result);
      }
    } catch (error) {
      console.error("Bidirectional sync error:", error);
      const errorMessage = `Bidirectional sync error: ${error.message || "Unknown error"}`;
      if (progressModal) {
        progressModal.addLog(`\u274C ${errorMessage}`);
        progressModal.updateStatus("Bidirectional sync failed", "error");
        setTimeout(() => progressModal == null ? void 0 : progressModal.markCancelled(), 2e3);
      } else {
        new import_obsidian.Notice(`\u274C ${errorMessage}`);
      }
      result.errors++;
    }
    return result;
  }
  // Google Drive 폴더에 해당하는 로컬 파일들 가져오기
  async getLocalFilesForDriveFolder(driveFolder) {
    const localFiles = [];
    const localFolderPath = driveFolder.path;
    const localFolder = this.app.vault.getAbstractFileByPath(localFolderPath);
    if (localFolder instanceof import_obsidian.TFolder) {
      const files = await this.collectFilesToSync(localFolder, this.settings.includeSubfolders);
      localFiles.push(...files);
    }
    return localFiles;
  }
  // 양방향 동기화 수행
  async performBidirectionalSync(localFiles, driveFiles, rootFolderId, result, baseFolder = "", progressModal) {
    const localFileMap = /* @__PURE__ */ new Map();
    localFiles.forEach((file) => {
      let relativePath = file.path;
      if (baseFolder && file.path.startsWith(baseFolder + "/")) {
        relativePath = file.path.substring(baseFolder.length + 1);
      } else if (baseFolder && file.path === baseFolder) {
        relativePath = "";
      }
      localFileMap.set(relativePath, file);
    });
    const driveFileMap = /* @__PURE__ */ new Map();
    driveFiles.forEach((file) => {
      let relativePath = file.path;
      if (baseFolder && file.path.startsWith(baseFolder + "/")) {
        relativePath = file.path.substring(baseFolder.length + 1);
      }
      driveFileMap.set(relativePath, file);
    });
    const allPaths = /* @__PURE__ */ new Set([...localFileMap.keys(), ...driveFileMap.keys()]);
    const totalFiles = allPaths.size;
    let processedFiles = 0;
    progressModal == null ? void 0 : progressModal.addLog(`\u{1F504} Processing ${totalFiles} unique file paths...`);
    for (const filePath of allPaths) {
      if (progressModal == null ? void 0 : progressModal.shouldCancel()) {
        return;
      }
      const localFile = localFileMap.get(filePath);
      const driveFile = driveFileMap.get(filePath);
      try {
        progressModal == null ? void 0 : progressModal.updateProgress(processedFiles, totalFiles, `Processing: ${filePath}`);
        if (localFile && driveFile) {
          progressModal == null ? void 0 : progressModal.addLog(`\u26A1 Conflict resolution: ${filePath}`);
          await this.resolveFileConflict(localFile, driveFile, rootFolderId, result);
        } else if (localFile && !driveFile) {
          progressModal == null ? void 0 : progressModal.addLog(`\u{1F4E4} Upload only: ${filePath}`);
          await this.uploadSingleFile(localFile, rootFolderId, result, baseFolder);
        } else if (!localFile && driveFile) {
          progressModal == null ? void 0 : progressModal.addLog(`\u{1F4E5} Download only: ${filePath}`);
          await this.downloadFileFromDrive(driveFile, result, baseFolder);
        }
      } catch (error) {
        console.error(`Error syncing file ${filePath}:`, error);
        progressModal == null ? void 0 : progressModal.addLog(`\u274C Error processing ${filePath}: ${error.message || "Unknown error"}`);
        result.errors++;
      }
      processedFiles++;
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
  }
  // Google Drive에서 파일 다운로드
  async downloadFileFromDrive(driveFile, result, baseFolder = "") {
    try {
      let filePath = driveFile.path;
      if (baseFolder && !filePath.startsWith(baseFolder)) {
        filePath = baseFolder + "/" + filePath;
      }
      const localFile = this.app.vault.getAbstractFileByPath(filePath);
      if (localFile instanceof import_obsidian.TFile) {
        const needsUpdate = await this.shouldDownloadFile(localFile, driveFile);
        if (!needsUpdate) {
          result.skipped++;
          return;
        }
      }
      const content = await this.getFileContentFromDrive(driveFile.id);
      const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
      if (folderPath && this.settings.createMissingFolders) {
        await this.createLocalFolderStructure(folderPath, result);
      }
      const remoteModTime = new Date(driveFile.modifiedTime).getTime();
      if (localFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(localFile, content);
        console.log(`\u{1F504} Updated local file: ${filePath}`);
      } else {
        await this.app.vault.create(filePath, content);
        console.log(`\u{1F4E5} Downloaded new file: ${filePath}`);
      }
      await this.syncFileTime(filePath, remoteModTime);
      result.downloaded++;
    } catch (error) {
      console.error(`Error downloading file ${driveFile.path}:`, error);
      throw error;
    }
  }
  // 파일 시간 동기화 메서드
  async syncFileTime(filePath, targetTime) {
    try {
      const adapter = this.app.vault.adapter;
      if (adapter.constructor.name === "FileSystemAdapter") {
        try {
          const fs = require("fs").promises;
          const path = require("path");
          const fullPath = path.join(adapter.basePath, filePath);
          const targetDate = new Date(targetTime);
          await fs.utimes(fullPath, targetDate, targetDate);
          console.log(`\u23F0 Synced file time: ${filePath} -> ${targetDate.toLocaleString()}`);
          return;
        } catch (fsError) {
          console.warn(`\u26A0\uFE0F Direct filesystem access failed: ${fsError}`);
        }
      }
      try {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian.TFile) {
          if (file.stat && file.stat.mtime !== void 0) {
            file.stat.mtime = targetTime;
            console.log(`\u23F0 Updated file stat time: ${filePath} -> ${new Date(targetTime).toLocaleString()}`);
            return;
          }
        }
      } catch (obsidianError) {
        console.warn(`\u26A0\uFE0F Obsidian API time sync failed: ${obsidianError}`);
      }
    } catch (error) {
      console.warn(`\u26A0\uFE0F File time sync failed for ${filePath}:`, error);
    }
  }
  // 로컬 폴더 구조 생성
  async createLocalFolderStructure(folderPath, result) {
    if (!folderPath)
      return;
    const pathParts = folderPath.split("/");
    let currentPath = "";
    for (const part of pathParts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const existingFolder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!existingFolder) {
        try {
          await this.app.vault.createFolder(currentPath);
          console.log(`\u{1F4C1} Created local folder: ${currentPath}`);
          result.createdFolders.push(currentPath);
        } catch (error) {
          if (!error.message.includes("already exists")) {
            throw error;
          }
        }
      }
    }
  }
  // 파일 충돌 해결
  async resolveFileConflict(localFile, driveFile, rootFolderId, result) {
    const localModTime = localFile.stat.mtime;
    const remoteModTime = new Date(driveFile.modifiedTime).getTime();
    let resolution;
    switch (this.settings.conflictResolution) {
      case "local":
        resolution = "local";
        break;
      case "remote":
        resolution = "remote";
        break;
      case "newer":
        resolution = localModTime > remoteModTime ? "local" : "remote";
        break;
      case "ask":
        resolution = localModTime > remoteModTime ? "local" : "remote";
        console.log(`Conflict resolved automatically (newer): ${localFile.path} -> ${resolution}`);
        break;
    }
    if (resolution === "local") {
      await this.uploadSingleFile(localFile, rootFolderId, result);
    } else {
      await this.downloadFileFromDrive(driveFile, result);
    }
    result.conflicts++;
  }
  // 단일 파일 업로드
  async uploadSingleFile(file, rootFolderId, result, baseFolder = "") {
    try {
      const syncResult = await this.syncFileToGoogleDrive(file, rootFolderId, baseFolder);
      if (syncResult === "skipped") {
        result.skipped++;
      } else if (syncResult === true) {
        result.uploaded++;
      } else {
        result.errors++;
      }
    } catch (error) {
      console.error(`Error uploading file ${file.path}:`, error);
      result.errors++;
    }
  }
  // 여러 파일 업로드
  async uploadFilesToDrive(filesToSync, rootFolderId, result) {
    for (const file of filesToSync) {
      await this.uploadSingleFile(file, rootFolderId, result);
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  // Google Drive에서 모든 파일 가져오기 (재귀적으로 폴더 구조 포함)
  async getAllFilesFromDrive(folderId, basePath = "") {
    const allFiles = [];
    try {
      let pageToken = "";
      do {
        const query = `'${folderId}' in parents and trashed=false`;
        const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,modifiedTime,size,parents)&pageSize=1000${pageToken ? `&pageToken=${pageToken}` : ""}`;
        const response = await (0, import_obsidian.requestUrl)({
          url,
          method: "GET",
          headers: {
            "Authorization": `Bearer ${this.settings.accessToken}`
          },
          throw: false
        });
        if (response.status !== 200) {
          console.error("Failed to list files:", response.status, response.json);
          break;
        }
        const data = response.json;
        for (const file of data.files || []) {
          const filePath = basePath ? `${basePath}/${file.name}` : file.name;
          if (file.mimeType === "application/vnd.google-apps.folder") {
            if (this.settings.includeSubfolders) {
              const subFiles = await this.getAllFilesFromDrive(file.id, filePath);
              allFiles.push(...subFiles);
            }
          } else {
            allFiles.push({
              ...file,
              path: filePath
            });
          }
        }
        pageToken = data.nextPageToken || "";
      } while (pageToken);
    } catch (error) {
      console.error("Error getting files from Drive:", error);
      throw error;
    }
    return allFiles;
  }
  // 파일 다운로드 필요 여부 판단
  async shouldDownloadFile(localFile, driveFile) {
    switch (this.settings.syncMode) {
      case "always":
        return true;
      case "modified":
        const localModTime = localFile.stat.mtime;
        const driveModTime = new Date(driveFile.modifiedTime).getTime();
        return driveModTime > localModTime;
      case "checksum":
        try {
          const localContent = await this.app.vault.read(localFile);
          const localHash = await this.calculateFileHash(localContent);
          const driveContent = await this.getFileContentFromDrive(driveFile.id);
          const driveHash = await this.calculateFileHash(driveContent);
          return localHash !== driveHash;
        } catch (error) {
          console.error("Error comparing file checksums:", error);
          return true;
        }
      default:
        return true;
    }
  }
  // 동기화 결과 객체 생성
  createEmptyResult() {
    return {
      uploaded: 0,
      downloaded: 0,
      skipped: 0,
      conflicts: 0,
      errors: 0,
      createdFolders: []
    };
  }
  // 동기화 결과 보고
  reportSyncResult(result) {
    const messages = [];
    if (result.uploaded > 0)
      messages.push(`${result.uploaded} uploaded`);
    if (result.downloaded > 0)
      messages.push(`${result.downloaded} downloaded`);
    if (result.skipped > 0)
      messages.push(`${result.skipped} skipped`);
    if (result.conflicts > 0)
      messages.push(`${result.conflicts} conflicts resolved`);
    if (result.createdFolders.length > 0)
      messages.push(`${result.createdFolders.length} folders created`);
    const summary = messages.length > 0 ? messages.join(", ") : "No changes";
    if (result.errors === 0) {
      new import_obsidian.Notice(`\u2705 Sync completed: ${summary}`);
    } else {
      new import_obsidian.Notice(`\u26A0\uFE0F Sync completed with ${result.errors} errors: ${summary}`);
    }
    if (result.createdFolders.length > 0) {
      console.log("Created folders:", result.createdFolders);
    }
  }
  // 파일 수집 메서드
  async collectFilesToSync(folder, includeSubfolders) {
    const files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile) {
        if (this.shouldSyncFileType(child)) {
          files.push(child);
        }
      } else if (child instanceof import_obsidian.TFolder && includeSubfolders) {
        const subfolderFiles = await this.collectFilesToSync(child, true);
        files.push(...subfolderFiles);
      }
    }
    return files;
  }
  shouldSyncFileType(file) {
    const syncExtensions = [".md", ".txt", ".json", ".csv", ".html", ".css", ".js"];
    const excludePatterns = [
      /^\./,
      // 숨김 파일
      /\.tmp$/,
      // 임시 파일
      /\.bak$/,
      // 백업 파일
      /\.lock$/
      // 락 파일
    ];
    const hasValidExtension = syncExtensions.some((ext) => file.name.endsWith(ext));
    const shouldExclude = excludePatterns.some((pattern) => pattern.test(file.name));
    return hasValidExtension && !shouldExclude;
  }
  // Google Drive 관련 메서드들
  async getOrCreateDriveFolder() {
    try {
      console.log(`Looking for Google Drive folder: ${this.settings.driveFolder}`);
      const searchResponse = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${this.settings.driveFolder}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (searchResponse.status === 200) {
        const searchData = searchResponse.json;
        if (searchData.files && searchData.files.length > 0) {
          const folder = searchData.files[0];
          console.log(`\u2713 Found existing folder: ${folder.name} (${folder.id})`);
          return { id: folder.id, name: folder.name };
        }
      }
      console.log(`Creating new Google Drive folder: ${this.settings.driveFolder}`);
      const createResponse = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/files",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: this.settings.driveFolder,
          mimeType: "application/vnd.google-apps.folder"
        }),
        throw: false
      });
      if (createResponse.status === 200 || createResponse.status === 201) {
        const folderData = createResponse.json;
        console.log(`\u2713 Created new folder: ${folderData.name} (${folderData.id})`);
        return { id: folderData.id, name: folderData.name };
      } else {
        console.error("Failed to create folder:", createResponse.status, createResponse.json);
        return null;
      }
    } catch (error) {
      console.error("Error managing Drive folder:", error);
      return null;
    }
  }
  async syncFileToGoogleDrive(file, rootFolderId, baseFolder = "") {
    try {
      let relativePath = file.path;
      if (baseFolder && file.path.startsWith(baseFolder + "/")) {
        relativePath = file.path.substring(baseFolder.length + 1);
      }
      let fileName = file.name;
      let targetFolderId = rootFolderId;
      if (relativePath.includes("/")) {
        const pathParts = relativePath.split("/");
        fileName = pathParts.pop();
        const folderPath = pathParts.join("/");
        console.log(`Creating folder structure: ${folderPath}`);
        targetFolderId = await this.createNestedFolders(folderPath, rootFolderId);
        if (!targetFolderId) {
          console.error(`Failed to create folder structure for: ${folderPath}`);
          return false;
        }
      }
      const existingFile = await this.findFileInDrive(fileName, targetFolderId);
      const needsSync = await this.shouldSyncFile(file, existingFile);
      if (!needsSync) {
        console.log(`\u23ED\uFE0F Skipping ${file.path} (no changes detected)`);
        return "skipped";
      }
      const content = await this.app.vault.read(file);
      const localModTime = file.stat.mtime;
      if (existingFile) {
        console.log(`\u{1F504} Updating ${file.path}`);
        return await this.updateFileInDrive(existingFile.id, content, localModTime);
      } else {
        console.log(`\u{1F4E4} Uploading ${file.path}`);
        return await this.uploadFileToDrive(fileName, content, targetFolderId, localModTime);
      }
    } catch (error) {
      console.error(`Error syncing file ${file.path}:`, error);
      return false;
    }
  }
  async shouldSyncFile(localFile, driveFile) {
    switch (this.settings.syncMode) {
      case "always":
        return true;
      case "modified":
        if (!driveFile) {
          return true;
        }
        const localModTime = localFile.stat.mtime;
        const driveModTime = new Date(driveFile.modifiedTime).getTime();
        return localModTime > driveModTime;
      case "checksum":
        if (!driveFile) {
          return true;
        }
        try {
          const localContent = await this.app.vault.read(localFile);
          const localHash = await this.calculateFileHash(localContent);
          const driveContent = await this.getFileContentFromDrive(driveFile.id);
          const driveHash = await this.calculateFileHash(driveContent);
          return localHash !== driveHash;
        } catch (error) {
          console.error("Error comparing file checksums:", error);
          return true;
        }
      default:
        return true;
    }
  }
  async calculateFileHash(content) {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async getFileContentFromDrive(fileId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode(response.arrayBuffer);
      } else {
        throw new Error(`Failed to download file: ${response.status}`);
      }
    } catch (error) {
      console.error("Error downloading file from Drive:", error);
      throw error;
    }
  }
  async createNestedFolders(folderPath, rootFolderId) {
    const pathParts = folderPath.split("/");
    let currentFolderId = rootFolderId;
    for (const folderName of pathParts) {
      if (!folderName)
        continue;
      const existingFolder = await this.findFolderInDrive(folderName, currentFolderId);
      if (existingFolder) {
        currentFolderId = existingFolder.id;
        console.log(`\u2713 Found existing folder: ${folderName}`);
      } else {
        const newFolder = await this.createFolderInDrive(folderName, currentFolderId);
        if (!newFolder) {
          throw new Error(`Failed to create folder: ${folderName}`);
        }
        currentFolderId = newFolder.id;
        console.log(`\u{1F4C1} Created folder: ${folderName}`);
      }
    }
    return currentFolderId;
  }
  async findFolderInDrive(folderName, parentFolderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${folderName}' and '${parentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false&fields=files(id,name)`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.files && data.files.length > 0) {
          return data.files[0];
        }
      }
      return null;
    } catch (error) {
      console.error("Error searching folder in Drive:", error);
      return null;
    }
  }
  async createFolderInDrive(folderName, parentFolderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/files",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: folderName,
          mimeType: "application/vnd.google-apps.folder",
          parents: [parentFolderId]
        }),
        throw: false
      });
      if (response.status === 200 || response.status === 201) {
        const folderData = response.json;
        return { id: folderData.id, name: folderData.name };
      } else {
        console.error("Failed to create folder:", response.status, response.json);
        return null;
      }
    } catch (error) {
      console.error("Error creating folder in Drive:", error);
      return null;
    }
  }
  async findFileInDrive(fileName, folderId) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/drive/v3/files?q=name='${fileName}' and '${folderId}' in parents and trashed=false&fields=files(id,name,modifiedTime)`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.files && data.files.length > 0) {
          return data.files[0];
        }
      }
      return null;
    } catch (error) {
      console.error("Error searching file in Drive:", error);
      return null;
    }
  }
  async uploadFileToDrive(fileName, content, folderId, localModTime) {
    try {
      const metadata = {
        name: fileName,
        parents: [folderId],
        modifiedTime: localModTime ? new Date(localModTime).toISOString() : void 0
      };
      const boundary = "-------314159265358979323846";
      const delimiter = "\r\n--" + boundary + "\r\n";
      const close_delim = "\r\n--" + boundary + "--";
      let body = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + "Content-Type: text/plain\r\n\r\n" + content + close_delim;
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": `multipart/related; boundary="${boundary}"`
        },
        body,
        throw: false
      });
      return response.status === 200 || response.status === 201;
    } catch (error) {
      console.error("Error uploading file to Drive:", error);
      return false;
    }
  }
  async updateFileInDrive(fileId, content, localModTime) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`,
        method: "PATCH",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`,
          "Content-Type": "text/plain"
        },
        body: content,
        throw: false
      });
      return response.status === 200;
    } catch (error) {
      console.error("Error updating file in Drive:", error);
      return false;
    }
  }
  setupAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    this.syncIntervalId = window.setInterval(() => {
      this.syncWithGoogleDrive();
    }, this.settings.syncInterval);
  }
  resetGoogleAPIState() {
    console.log("Resetting Google API state...");
    this.isGoogleApiLoaded = false;
    console.log("Google API state reset completed");
  }
  async testDriveAPIConnection() {
    var _a;
    try {
      if (!this.settings.accessToken) {
        console.log("No access token available for testing");
        new import_obsidian.Notice("\u274C Please authenticate first");
        return false;
      }
      console.log("Testing Google Drive API connection...");
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://www.googleapis.com/drive/v3/about?fields=user",
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.accessToken}`
        },
        throw: false
      });
      console.log("API Response Status:", response.status);
      if (response.status === 200) {
        const data = response.json;
        console.log("Drive API test successful:", data);
        new import_obsidian.Notice(`\u2705 Drive API connection successful. User: ${((_a = data.user) == null ? void 0 : _a.displayName) || "Unknown"}`);
        return true;
      } else if (response.status === 401) {
        console.error("Authentication failed - Token expired or invalid");
        new import_obsidian.Notice("\u274C Authentication expired. Please sign in again.");
        this.settings.accessToken = "";
        await this.saveSettings();
        new import_obsidian.Notice('Click "1. Open Auth URL" again to re-authenticate.');
        return false;
      } else if (response.status === 403) {
        console.error("API access denied - Check API key and permissions");
        new import_obsidian.Notice("\u274C API access denied. Check your API Key and Drive API is enabled.");
        return false;
      } else {
        console.error(`Drive API test failed: ${response.status}`);
        new import_obsidian.Notice(`\u274C Drive API connection failed (Status: ${response.status}). Check console for details.`);
        return false;
      }
    } catch (error) {
      console.error("Drive API test error:", error);
      new import_obsidian.Notice("\u274C Unexpected error occurred. Check console for details.");
      return false;
    }
  }
};
var GDriveSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Google Drive Folder-Based Sync Settings" });
    containerEl.createEl("h3", { text: "Google Drive API Configuration" });
    new import_obsidian.Setting(containerEl).setName("Client ID").setDesc("Google Drive API Client ID (Desktop Application type)").addText((text) => text.setPlaceholder("Enter your Client ID").setValue(this.plugin.settings.clientId).onChange(async (value) => {
      this.plugin.settings.clientId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Client Secret").setDesc("Google Drive API Client Secret (from Google Cloud Console)").addText((text) => text.setPlaceholder("Enter your Client Secret").setValue(this.plugin.settings.clientSecret).onChange(async (value) => {
      this.plugin.settings.clientSecret = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Google Drive API Key (from Google Cloud Console)").addText((text) => text.setPlaceholder("Enter your API Key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Authentication" });
    new import_obsidian.Setting(containerEl).setName("Check Configuration").setDesc("Verify that Client ID, Client Secret, and API Key are properly configured").addButton((button) => button.setButtonText("Check").onClick(() => {
      if (!this.plugin.settings.clientId || !this.plugin.settings.clientSecret || !this.plugin.settings.apiKey) {
        new import_obsidian.Notice("\u274C Please set Client ID, Client Secret, and API Key");
      } else {
        new import_obsidian.Notice("\u2705 Configuration looks good! You can now authenticate.");
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Desktop App Authentication").setDesc("Authenticate with Google Drive using Desktop Application Client ID").addButton((button) => button.setButtonText("1. Open Auth URL").setCta().onClick(async () => {
      if (!this.plugin.settings.clientId || !this.plugin.settings.clientSecret) {
        new import_obsidian.Notice("\u274C Please set Client ID and Client Secret first");
        return;
      }
      await this.plugin.authenticateGoogleDrive();
    }));
    new import_obsidian.Setting(containerEl).setName("Authorization Code").setDesc("Step 2: After authentication, paste the authorization code here").addText((text) => text.setPlaceholder("Paste authorization code here...").setValue("").onChange(async (value) => {
    })).addButton((button) => button.setButtonText("2. Exchange for Token").setCta().onClick(async (evt) => {
      var _a;
      const textInput = containerEl.querySelector('input[placeholder="Paste authorization code here..."]');
      const authCode = (_a = textInput == null ? void 0 : textInput.value) == null ? void 0 : _a.trim();
      if (!authCode) {
        new import_obsidian.Notice("\u274C Please enter authorization code first");
        return;
      }
      console.log("Attempting to exchange authorization code...");
      const success = await this.plugin.exchangeCodeForToken(authCode);
      if (success) {
        if (textInput)
          textInput.value = "";
        setTimeout(async () => {
          await this.plugin.testDriveAPIConnection();
        }, 1e3);
      }
    }));
    containerEl.createEl("h3", { text: "Sync Configuration" });
    new import_obsidian.Setting(containerEl).setName("Google Drive Root Folder").setDesc("Name of the root folder to create/use in Google Drive").addText((text) => text.setPlaceholder("e.g., Obsidian-Sync").setValue(this.plugin.settings.driveFolder).onChange(async (value) => {
      this.plugin.settings.driveFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Direction").setDesc("Choose how files should be synchronized").addDropdown((dropdown) => dropdown.addOption("bidirectional", "\u{1F504} Bidirectional (Upload & Download)").addOption("upload", "\u{1F4E4} Upload Only (Local \u2192 Drive)").addOption("download", "\u{1F4E5} Download Only (Drive \u2192 Local)").setValue(this.plugin.settings.syncDirection).onChange(async (value) => {
      this.plugin.settings.syncDirection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Conflict Resolution").setDesc("How to handle conflicts when both local and remote files exist").addDropdown((dropdown) => dropdown.addOption("newer", "\u{1F552} Use Newer File (recommended)").addOption("local", "\u{1F4F1} Always Use Local File").addOption("remote", "\u2601\uFE0F Always Use Remote File").addOption("ask", "\u2753 Ask User (manual resolution)").setValue(this.plugin.settings.conflictResolution).onChange(async (value) => {
      this.plugin.settings.conflictResolution = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Create Missing Folders").setDesc("Automatically create local folders when downloading files from Google Drive").addToggle((toggle) => toggle.setValue(this.plugin.settings.createMissingFolders).onChange(async (value) => {
      this.plugin.settings.createMissingFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Whole Vault").setDesc("Enable to sync the entire vault instead of selected Google Drive folders").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncWholeVault).onChange(async (value) => {
      this.plugin.settings.syncWholeVault = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (!this.plugin.settings.syncWholeVault) {
      const syncFoldersSection = containerEl.createEl("div", { cls: "sync-folders-section" });
      syncFoldersSection.createEl("h4", { text: "Google Drive Folders to Sync" });
      const currentFoldersEl = syncFoldersSection.createEl("div", { cls: "current-drive-folders" });
      this.updateCurrentDriveFoldersDisplay(currentFoldersEl);
      new import_obsidian.Setting(syncFoldersSection).setName("Select Google Drive Folder").setDesc("Choose top-level folders from Google Drive to sync with local vault").addButton((button) => button.setButtonText("Browse Google Drive").setCta().onClick(async () => {
        if (!this.plugin.isAuthenticated()) {
          new import_obsidian.Notice("\u274C Please authenticate with Google Drive first");
          return;
        }
        await this.openDriveFolderSelector();
      }));
      new import_obsidian.Setting(syncFoldersSection).setName("Clear All Folders").setDesc("Remove all selected Google Drive folders").addButton((button) => button.setButtonText("Clear All").setWarning().onClick(async () => {
        this.plugin.settings.selectedDriveFolders = [];
        await this.plugin.saveSettings();
        this.updateCurrentDriveFoldersDisplay(currentFoldersEl);
        new import_obsidian.Notice("All Google Drive folders cleared");
      }));
    }
    new import_obsidian.Setting(containerEl).setName("Include Subfolders").setDesc("Sync files from subfolders recursively").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeSubfolders).onChange(async (value) => {
      this.plugin.settings.includeSubfolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync at regular intervals").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.setupAutoSync();
      } else if (this.plugin.syncIntervalId) {
        window.clearInterval(this.plugin.syncIntervalId);
        this.plugin.syncIntervalId = null;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("How often to sync (in minutes)").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.syncInterval / 6e4).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.syncInterval = value * 6e4;
      await this.plugin.saveSettings();
      if (this.plugin.settings.autoSync) {
        this.plugin.setupAutoSync();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Mode").setDesc("How to determine if files need to be synced").addDropdown((dropdown) => dropdown.addOption("always", "Always sync (force upload)").addOption("modified", "Modified time comparison (recommended)").addOption("checksum", "Content checksum comparison (most accurate)").setValue(this.plugin.settings.syncMode).onChange(async (value) => {
      this.plugin.settings.syncMode = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Sync Actions" });
    new import_obsidian.Setting(containerEl).setName("Full Bidirectional Sync").setDesc("Perform complete bidirectional synchronization with detailed progress").addButton((button) => button.setButtonText("\u{1F504} Sync Both Ways").setCta().onClick(async () => {
      const originalDirection = this.plugin.settings.syncDirection;
      this.plugin.settings.syncDirection = "bidirectional";
      try {
        await this.plugin.bidirectionalSync(true);
      } finally {
        this.plugin.settings.syncDirection = originalDirection;
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Upload to Google Drive").setDesc("Upload only: Send local files to Google Drive with progress tracking").addButton((button) => button.setButtonText("\u{1F4E4} Upload Only").onClick(async () => {
      await this.plugin.uploadToGoogleDrive(true);
    }));
    new import_obsidian.Setting(containerEl).setName("Download from Google Drive").setDesc("Download only: Get files from Google Drive with progress tracking").addButton((button) => button.setButtonText("\u{1F4E5} Download Only").onClick(async () => {
      await this.plugin.downloadFromGoogleDrive(true);
    }));
    new import_obsidian.Setting(containerEl).setName("Preview Sync").setDesc("Show what files would be synced (without actually syncing)").addButton((button) => button.setButtonText("Preview").onClick(async () => {
      await this.previewSync();
    }));
    containerEl.createEl("h3", { text: "Testing & Debugging" });
    new import_obsidian.Setting(containerEl).setName("Test API Connection").setDesc("Test your current access token with Google Drive API").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      await this.plugin.testDriveAPIConnection();
    }));
    new import_obsidian.Setting(containerEl).setName("Browse Google Drive Folders").setDesc("View and manage Google Drive folder structure").addButton((button) => button.setButtonText("Browse Folders").onClick(async () => {
      if (!this.plugin.isAuthenticated()) {
        new import_obsidian.Notice("\u274C Please authenticate with Google Drive first");
        return;
      }
      await this.openDriveFolderBrowser();
    }));
    new import_obsidian.Setting(containerEl).setName("Sign Out").setDesc("Revoke Google Drive access and sign out").addButton((button) => button.setButtonText("Sign Out").setWarning().onClick(async () => {
      await this.plugin.revokeGoogleDriveAccess();
      this.display();
    }));
    containerEl.createEl("h3", { text: "Status Information" });
    const statusEl = containerEl.createEl("div");
    const updateStatus = () => {
      const isAuth = this.plugin.isAuthenticated();
      const selectedFoldersCount = this.plugin.settings.selectedDriveFolders.length;
      statusEl.innerHTML = `
                <div style="padding: 10px; border-radius: 4px; margin-bottom: 10px; ${isAuth ? "background-color: #d4edda; border: 1px solid #c3e6cb; color: #155724;" : "background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24;"}">
                    <strong>Authentication:</strong> ${isAuth ? "\u2705 Authenticated" : "\u274C Not Authenticated"}
                    ${this.plugin.settings.accessToken ? "<br><small>Access token is stored</small>" : "<br><small>No access token stored</small>"}
                </div>
                <div style="padding: 10px; border-radius: 4px; margin-bottom: 10px; background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460;">
                    <strong>Sync Mode:</strong> ${this.plugin.settings.syncWholeVault ? "\u{1F4C1} Whole Vault" : `\u{1F4C2} Selected Folders (${selectedFoldersCount} selected)`}
                    <br><small>Google Drive Root: ${this.plugin.settings.driveFolder}</small>
                    <br><small>Sync Direction: ${this.plugin.settings.syncDirection === "bidirectional" ? "\u{1F504} Bidirectional" : this.plugin.settings.syncDirection === "upload" ? "\u{1F4E4} Upload Only" : "\u{1F4E5} Download Only"}</small>
                    <br><small>Conflict Resolution: ${this.plugin.settings.conflictResolution === "newer" ? "\u{1F552} Use Newer File" : this.plugin.settings.conflictResolution === "local" ? "\u{1F4F1} Always Use Local" : this.plugin.settings.conflictResolution === "remote" ? "\u2601\uFE0F Always Use Remote" : "\u2753 Ask User"}</small>
                    ${this.plugin.settings.lastSyncTime ? `<br><small>Last Sync: ${new Date(this.plugin.settings.lastSyncTime).toLocaleString()}</small>` : "<br><small>Never synced</small>"}
                </div>
            `;
    };
    updateStatus();
    containerEl.createEl("h3", { text: "Setup Instructions" });
    const instructionsEl = containerEl.createEl("div");
    instructionsEl.innerHTML = `
        <div style="background-color: #d4edda; border: 1px solid #c3e6cb; padding: 10px; margin: 10px 0; border-radius: 4px;">
            <p><strong>\u2705 Google Cloud Console \uC124\uC815:</strong></p>
            <ol>
                <li><a href="https://console.cloud.google.com/apis/credentials" target="_blank">Google Cloud Console - Credentials</a> \uC811\uC18D</li>
                <li>"Create Credentials" \u2192 "OAuth client ID" \uC120\uD0DD</li>
                <li><strong>Application type: "Desktop application"</strong> \uC120\uD0DD</li>
                <li>Name \uC785\uB825 \uD6C4 "Create" \uD074\uB9AD</li>
                <li>\uC0DD\uC131\uB41C Client ID\uC640 Client Secret\uC744 \uC704 \uC124\uC815\uC5D0 \uC785\uB825</li>
                <li>Google Drive API\uAC00 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uB294\uC9C0 \uD655\uC778</li>
            </ol>
        </div>
        <div style="background-color: #e7f3ff; border: 1px solid #b3d7ff; padding: 10px; margin: 10px 0; border-radius: 4px;">
            <p><strong>\u{1F504} Google Drive \uAE30\uBC18 \uB3D9\uAE30\uD654:</strong></p>
            <ul>
                <li><strong>\u{1F4C1} Whole Vault:</strong> \uC804\uCCB4 \uBCFC\uD2B8\uB97C Google Drive \uB8E8\uD2B8 \uD3F4\uB354\uC640 \uB3D9\uAE30\uD654</li>
                <li><strong>\u{1F4C2} Selected Folders:</strong> Google Drive\uC5D0\uC11C \uC120\uD0DD\uD55C \uCD5C\uC0C1\uC704 \uD3F4\uB354\uB4E4\uB9CC \uB85C\uCEEC\uACFC \uB3D9\uAE30\uD654</li>
                <li><strong>\u{1F3D7}\uFE0F \uD3F4\uB354 \uC0DD\uC131:</strong> Google Drive\uC5D0\uC11C \uC0C8 \uCD5C\uC0C1\uC704 \uD3F4\uB354\uB97C \uC0DD\uC131\uD558\uACE0 \uC120\uD0DD \uAC00\uB2A5</li>
                <li><strong>\u{1F5D1}\uFE0F \uD3F4\uB354 \uC0AD\uC81C:</strong> Google Drive\uC758 \uCD5C\uC0C1\uC704 \uD3F4\uB354\uB97C \uD734\uC9C0\uD1B5\uC73C\uB85C \uC774\uB3D9</li>
                <li><strong>\u{1F50D} \uD3F4\uB354 \uBE0C\uB77C\uC6B0\uC9D5:</strong> Google Drive \uCD5C\uC0C1\uC704 \uD3F4\uB354 \uAD6C\uC870\uB97C \uD0D0\uC0C9\uD558\uACE0 \uAD00\uB9AC</li>
            </ul>
            <p><strong>\u{1F4A1} \uC0AC\uC6A9 \uBC29\uBC95:</strong></p>
            <ol>
                <li>Google Cloud Console\uC5D0\uC11C API \uC124\uC815 \uC644\uB8CC</li>
                <li>Desktop App Authentication\uC73C\uB85C \uC778\uC99D</li>
                <li>"Browse Google Drive" \uBC84\uD2BC\uC73C\uB85C \uCD5C\uC0C1\uC704 \uD3F4\uB354 \uAD6C\uC870 \uD655\uC778</li>
                <li>\uB3D9\uAE30\uD654\uD560 Google Drive \uCD5C\uC0C1\uC704 \uD3F4\uB354 \uC120\uD0DD</li>
                <li>\uC120\uD0DD\uB41C \uD3F4\uB354\uB4E4\uC774 \uB85C\uCEEC \uACBD\uB85C\uC640 \uC790\uB3D9 \uB9E4\uD551\uB418\uC5B4 \uB3D9\uAE30\uD654</li>
            </ol>
        </div>
        <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; margin: 10px 0; border-radius: 4px;">
            <p><strong>\u26A0\uFE0F \uC911\uC694\uC0AC\uD56D:</strong></p>
            <ul>
                <li>\uCD5C\uC0C1\uC704 \uD3F4\uB354\uB9CC \uC120\uD0DD \uAC00\uB2A5\uD558\uBA70, \uD558\uC704 \uD3F4\uB354\uB294 \uC790\uB3D9\uC73C\uB85C \uD3EC\uD568\uB429\uB2C8\uB2E4</li>
                <li>Google Drive\uC5D0\uC11C \uC120\uD0DD\uD55C \uD3F4\uB354 \uACBD\uB85C\uAC00 \uB85C\uCEEC \uBCFC\uD2B8 \uACBD\uB85C\uC640 \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4</li>
                <li>\uC608: Google Drive\uC758 "Notes" \uD3F4\uB354\uB294 \uB85C\uCEEC\uC758 "Notes" \uD3F4\uB354\uC640 \uB3D9\uAE30\uD654</li>
                <li>\uD3F4\uB354 \uC0AD\uC81C \uC2DC Google Drive \uD734\uC9C0\uD1B5\uC73C\uB85C \uC774\uB3D9\uB418\uBBC0\uB85C \uBCF5\uAD6C \uAC00\uB2A5\uD569\uB2C8\uB2E4</li>
                <li>"Whole Vault" \uBAA8\uB4DC\uC5D0\uC11C\uB294 \uBAA8\uB4E0 \uD3F4\uB354\uAC00 \uB3D9\uAE30\uD654\uB429\uB2C8\uB2E4</li>
            </ul>
        </div>
        `;
  }
  // 현재 선택된 Google Drive 폴더들 표시 업데이트
  updateCurrentDriveFoldersDisplay(containerEl) {
    containerEl.empty();
    if (this.plugin.settings.selectedDriveFolders.length === 0) {
      containerEl.createEl("p", { text: "No Google Drive folders selected for sync", cls: "setting-item-description" });
      return;
    }
    containerEl.createEl("p", { text: "Selected Google Drive folders:", cls: "setting-item-description" });
    const folderList = containerEl.createEl("div", { cls: "sync-drive-folders-list" });
    this.plugin.settings.selectedDriveFolders.forEach((folder, index) => {
      const folderItem = folderList.createEl("div", {
        cls: "sync-drive-folder-item",
        attr: { style: "display: flex; align-items: center; margin-bottom: 5px; padding: 8px; background-color: var(--background-secondary); border-radius: 3px;" }
      });
      const folderIcon = folderItem.createEl("span", {
        text: "\u2601\uFE0F",
        attr: { style: "margin-right: 8px;" }
      });
      const folderInfo = folderItem.createEl("div", {
        attr: { style: "flex-grow: 1; margin-right: 10px;" }
      });
      const folderName = folderInfo.createEl("div", {
        text: folder.name,
        attr: { style: "font-weight: bold;" }
      });
      const folderPath = folderInfo.createEl("small", {
        text: `Path: ${folder.path || "/"}`,
        attr: { style: "color: var(--text-muted); font-size: 0.8em;" }
      });
      const folderId = folderInfo.createEl("small", {
        text: `ID: ${folder.id}`,
        attr: { style: "color: var(--text-muted); font-size: 0.8em; display: block;" }
      });
      const removeButton = folderItem.createEl("button", {
        text: "\u2716",
        cls: "mod-warning",
        attr: { style: "min-width: 24px; height: 24px; padding: 0; border-radius: 3px;" }
      });
      removeButton.onclick = async () => {
        this.plugin.settings.selectedDriveFolders.splice(index, 1);
        await this.plugin.saveSettings();
        this.updateCurrentDriveFoldersDisplay(containerEl);
        new import_obsidian.Notice(`Removed Google Drive folder: ${folder.name}`);
      };
    });
  }
  // Google Drive 폴더 선택 모달 열기
  async openDriveFolderSelector() {
    const modal = new DriveFolderModal(this.app, this.plugin, async (selectedFolder) => {
      const alreadySelected = this.plugin.settings.selectedDriveFolders.some(
        (folder) => folder.id === selectedFolder.id
      );
      if (alreadySelected) {
        new import_obsidian.Notice(`Folder "${selectedFolder.name}" is already selected`);
        return;
      }
      this.plugin.settings.selectedDriveFolders.push({
        id: selectedFolder.id,
        name: selectedFolder.name,
        path: selectedFolder.path
      });
      await this.plugin.saveSettings();
      const currentFoldersEl = document.querySelector(".current-drive-folders");
      if (currentFoldersEl) {
        this.updateCurrentDriveFoldersDisplay(currentFoldersEl);
      }
      new import_obsidian.Notice(`Added Google Drive folder: ${selectedFolder.name}`);
    });
    modal.open();
  }
  // Google Drive 폴더 브라우저 열기 (관리용)
  async openDriveFolderBrowser() {
    const modal = new DriveFolderModal(this.app, this.plugin, (selectedFolder) => {
      console.log("Selected folder for browsing:", selectedFolder);
      new import_obsidian.Notice(`Folder info: ${selectedFolder.name} (${selectedFolder.path})`);
    });
    modal.open();
  }
  // 동기화 미리보기
  async previewSync() {
    if (!this.plugin.isAuthenticated()) {
      new import_obsidian.Notice("\u274C Please authenticate first");
      return;
    }
    try {
      console.log("=== GOOGLE DRIVE FOLDER-BASED SYNC PREVIEW ===");
      console.log(`Google Drive root folder: ${this.plugin.settings.driveFolder}`);
      console.log(`Sync direction: ${this.plugin.settings.syncDirection}`);
      console.log(`Sync whole vault: ${this.plugin.settings.syncWholeVault}`);
      console.log(`Selected Drive folders: ${this.plugin.settings.selectedDriveFolders.length}`);
      if (this.plugin.settings.syncWholeVault) {
        const localFiles = this.plugin.app.vault.getFiles().filter((file) => this.plugin.shouldSyncFileType(file));
        console.log(`
\u{1F4F1} LOCAL FILES (Whole Vault): ${localFiles.length} files`);
        const rootFolder = await this.plugin.getOrCreateDriveFolder();
        if (rootFolder) {
          const driveFiles = await this.plugin.getAllFilesFromDrive(rootFolder.id);
          console.log(`\u2601\uFE0F GOOGLE DRIVE FILES: ${driveFiles.length} files`);
          const summary = `\u{1F4CB} Preview: ${localFiles.length} local files, ${driveFiles.length} remote files`;
          new import_obsidian.Notice(summary);
        }
      } else {
        if (this.plugin.settings.selectedDriveFolders.length === 0) {
          new import_obsidian.Notice("\u274C No Google Drive folders selected");
          return;
        }
        let totalLocalFiles = 0;
        let totalDriveFiles = 0;
        console.log(`
\u{1F4C2} SELECTED GOOGLE DRIVE FOLDERS (${this.plugin.settings.selectedDriveFolders.length}):`);
        for (const driveFolder of this.plugin.settings.selectedDriveFolders) {
          console.log(`
\u{1F4C1} Processing: ${driveFolder.name} (${driveFolder.path})`);
          const localFiles = await this.plugin.getLocalFilesForDriveFolder(driveFolder);
          totalLocalFiles += localFiles.length;
          console.log(`  \u{1F4F1} Local files: ${localFiles.length}`);
          const driveFiles = await this.plugin.getAllFilesFromDrive(driveFolder.id, driveFolder.path);
          totalDriveFiles += driveFiles.length;
          console.log(`  \u2601\uFE0F Drive files: ${driveFiles.length}`);
        }
        const summary = `\u{1F4CB} Preview: ${totalLocalFiles} local files, ${totalDriveFiles} remote files in ${this.plugin.settings.selectedDriveFolders.length} folders`;
        console.log(`
${summary}`);
        new import_obsidian.Notice(summary + ". Check console for details.");
      }
    } catch (error) {
      console.error("Preview sync error:", error);
      new import_obsidian.Notice("\u274C Failed to preview sync. Check console for details.");
    }
  }
};
